# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _iDynTree
else:
    import _iDynTree

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_SwigPyIterator

    def value(self):
        return _iDynTree.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _iDynTree.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _iDynTree.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _iDynTree.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _iDynTree.SwigPyIterator_equal(self, x)

    def copy(self):
        return _iDynTree.SwigPyIterator_copy(self)

    def next(self):
        return _iDynTree.SwigPyIterator_next(self)

    def __next__(self):
        return _iDynTree.SwigPyIterator___next__(self)

    def previous(self):
        return _iDynTree.SwigPyIterator_previous(self)

    def advance(self, n):
        return _iDynTree.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _iDynTree.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _iDynTree.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _iDynTree.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _iDynTree.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _iDynTree.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _iDynTree.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _iDynTree:
_iDynTree.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.StringVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.StringVector___bool__(self)

    def __len__(self):
        return _iDynTree.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.StringVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.StringVector_pop(self)

    def append(self, x):
        return _iDynTree.StringVector_append(self, x)

    def empty(self):
        return _iDynTree.StringVector_empty(self)

    def size(self):
        return _iDynTree.StringVector_size(self)

    def swap(self, v):
        return _iDynTree.StringVector_swap(self, v)

    def begin(self):
        return _iDynTree.StringVector_begin(self)

    def end(self):
        return _iDynTree.StringVector_end(self)

    def rbegin(self):
        return _iDynTree.StringVector_rbegin(self)

    def rend(self):
        return _iDynTree.StringVector_rend(self)

    def clear(self):
        return _iDynTree.StringVector_clear(self)

    def get_allocator(self):
        return _iDynTree.StringVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.StringVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.StringVector_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.StringVector_swiginit(self, _iDynTree.new_StringVector(*args))

    def push_back(self, x):
        return _iDynTree.StringVector_push_back(self, x)

    def front(self):
        return _iDynTree.StringVector_front(self)

    def back(self):
        return _iDynTree.StringVector_back(self)

    def assign(self, n, x):
        return _iDynTree.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.StringVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.StringVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.StringVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.StringVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_StringVector

# Register StringVector in _iDynTree:
_iDynTree.StringVector_swigregister(StringVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.IntVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.IntVector___bool__(self)

    def __len__(self):
        return _iDynTree.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.IntVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.IntVector_pop(self)

    def append(self, x):
        return _iDynTree.IntVector_append(self, x)

    def empty(self):
        return _iDynTree.IntVector_empty(self)

    def size(self):
        return _iDynTree.IntVector_size(self)

    def swap(self, v):
        return _iDynTree.IntVector_swap(self, v)

    def begin(self):
        return _iDynTree.IntVector_begin(self)

    def end(self):
        return _iDynTree.IntVector_end(self)

    def rbegin(self):
        return _iDynTree.IntVector_rbegin(self)

    def rend(self):
        return _iDynTree.IntVector_rend(self)

    def clear(self):
        return _iDynTree.IntVector_clear(self)

    def get_allocator(self):
        return _iDynTree.IntVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.IntVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.IntVector_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.IntVector_swiginit(self, _iDynTree.new_IntVector(*args))

    def push_back(self, x):
        return _iDynTree.IntVector_push_back(self, x)

    def front(self):
        return _iDynTree.IntVector_front(self)

    def back(self):
        return _iDynTree.IntVector_back(self)

    def assign(self, n, x):
        return _iDynTree.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.IntVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.IntVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.IntVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.IntVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_IntVector

# Register IntVector in _iDynTree:
_iDynTree.IntVector_swigregister(IntVector)

class BerdySensors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.BerdySensors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.BerdySensors___nonzero__(self)

    def __bool__(self):
        return _iDynTree.BerdySensors___bool__(self)

    def __len__(self):
        return _iDynTree.BerdySensors___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.BerdySensors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.BerdySensors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.BerdySensors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.BerdySensors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.BerdySensors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.BerdySensors___setitem__(self, *args)

    def pop(self):
        return _iDynTree.BerdySensors_pop(self)

    def append(self, x):
        return _iDynTree.BerdySensors_append(self, x)

    def empty(self):
        return _iDynTree.BerdySensors_empty(self)

    def size(self):
        return _iDynTree.BerdySensors_size(self)

    def swap(self, v):
        return _iDynTree.BerdySensors_swap(self, v)

    def begin(self):
        return _iDynTree.BerdySensors_begin(self)

    def end(self):
        return _iDynTree.BerdySensors_end(self)

    def rbegin(self):
        return _iDynTree.BerdySensors_rbegin(self)

    def rend(self):
        return _iDynTree.BerdySensors_rend(self)

    def clear(self):
        return _iDynTree.BerdySensors_clear(self)

    def get_allocator(self):
        return _iDynTree.BerdySensors_get_allocator(self)

    def pop_back(self):
        return _iDynTree.BerdySensors_pop_back(self)

    def erase(self, *args):
        return _iDynTree.BerdySensors_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.BerdySensors_swiginit(self, _iDynTree.new_BerdySensors(*args))

    def push_back(self, x):
        return _iDynTree.BerdySensors_push_back(self, x)

    def front(self):
        return _iDynTree.BerdySensors_front(self)

    def back(self):
        return _iDynTree.BerdySensors_back(self)

    def assign(self, n, x):
        return _iDynTree.BerdySensors_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.BerdySensors_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.BerdySensors_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.BerdySensors_reserve(self, n)

    def capacity(self):
        return _iDynTree.BerdySensors_capacity(self)
    __swig_destroy__ = _iDynTree.delete_BerdySensors

# Register BerdySensors in _iDynTree:
_iDynTree.BerdySensors_swigregister(BerdySensors)

class BerdyDynamicVariables(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.BerdyDynamicVariables_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.BerdyDynamicVariables___nonzero__(self)

    def __bool__(self):
        return _iDynTree.BerdyDynamicVariables___bool__(self)

    def __len__(self):
        return _iDynTree.BerdyDynamicVariables___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.BerdyDynamicVariables___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.BerdyDynamicVariables___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.BerdyDynamicVariables___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.BerdyDynamicVariables___setitem__(self, *args)

    def pop(self):
        return _iDynTree.BerdyDynamicVariables_pop(self)

    def append(self, x):
        return _iDynTree.BerdyDynamicVariables_append(self, x)

    def empty(self):
        return _iDynTree.BerdyDynamicVariables_empty(self)

    def size(self):
        return _iDynTree.BerdyDynamicVariables_size(self)

    def swap(self, v):
        return _iDynTree.BerdyDynamicVariables_swap(self, v)

    def begin(self):
        return _iDynTree.BerdyDynamicVariables_begin(self)

    def end(self):
        return _iDynTree.BerdyDynamicVariables_end(self)

    def rbegin(self):
        return _iDynTree.BerdyDynamicVariables_rbegin(self)

    def rend(self):
        return _iDynTree.BerdyDynamicVariables_rend(self)

    def clear(self):
        return _iDynTree.BerdyDynamicVariables_clear(self)

    def get_allocator(self):
        return _iDynTree.BerdyDynamicVariables_get_allocator(self)

    def pop_back(self):
        return _iDynTree.BerdyDynamicVariables_pop_back(self)

    def erase(self, *args):
        return _iDynTree.BerdyDynamicVariables_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.BerdyDynamicVariables_swiginit(self, _iDynTree.new_BerdyDynamicVariables(*args))

    def push_back(self, x):
        return _iDynTree.BerdyDynamicVariables_push_back(self, x)

    def front(self):
        return _iDynTree.BerdyDynamicVariables_front(self)

    def back(self):
        return _iDynTree.BerdyDynamicVariables_back(self)

    def assign(self, n, x):
        return _iDynTree.BerdyDynamicVariables_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.BerdyDynamicVariables_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.BerdyDynamicVariables_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.BerdyDynamicVariables_reserve(self, n)

    def capacity(self):
        return _iDynTree.BerdyDynamicVariables_capacity(self)
    __swig_destroy__ = _iDynTree.delete_BerdyDynamicVariables

# Register BerdyDynamicVariables in _iDynTree:
_iDynTree.BerdyDynamicVariables_swigregister(BerdyDynamicVariables)


def reportInfo(className, methodName, message):
    return _iDynTree.reportInfo(className, methodName, message)

def reportDebug(className, methodName, message):
    return _iDynTree.reportDebug(className, methodName, message)
class IndexRange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    offset = property(_iDynTree.IndexRange_offset_get, _iDynTree.IndexRange_offset_set)
    size = property(_iDynTree.IndexRange_size_get, _iDynTree.IndexRange_size_set)

    def isValid(self):
        return _iDynTree.IndexRange_isValid(self)

    @staticmethod
    def InvalidRange():
        return _iDynTree.IndexRange_InvalidRange()

    def __init__(self):
        _iDynTree.IndexRange_swiginit(self, _iDynTree.new_IndexRange())
    __swig_destroy__ = _iDynTree.delete_IndexRange

# Register IndexRange in _iDynTree:
_iDynTree.IndexRange_swigregister(IndexRange)

def IndexRange_InvalidRange():
    return _iDynTree.IndexRange_InvalidRange()

RowMajor = _iDynTree.RowMajor
ColumnMajor = _iDynTree.ColumnMajor

def checkDoublesAreEqual(*args):
    return _iDynTree.checkDoublesAreEqual(*args)
class MatrixDynSize(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.MatrixDynSize_swiginit(self, _iDynTree.new_MatrixDynSize(*args))
    __swig_destroy__ = _iDynTree.delete_MatrixDynSize

    def __call__(self, *args):
        return _iDynTree.MatrixDynSize___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.MatrixDynSize_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.MatrixDynSize_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.MatrixDynSize_rows(self)

    def cols(self):
        return _iDynTree.MatrixDynSize_cols(self)

    def data(self):
        return _iDynTree.MatrixDynSize_data(self)

    def zero(self):
        return _iDynTree.MatrixDynSize_zero(self)

    def resize(self, _newRows, _newCols):
        return _iDynTree.MatrixDynSize_resize(self, _newRows, _newCols)

    def reserve(self, _newCapacity):
        return _iDynTree.MatrixDynSize_reserve(self, _newCapacity)

    def capacity(self):
        return _iDynTree.MatrixDynSize_capacity(self)

    def shrink_to_fit(self):
        return _iDynTree.MatrixDynSize_shrink_to_fit(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.MatrixDynSize_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.MatrixDynSize_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.MatrixDynSize_toString(self)

    def __str__(self):
        return _iDynTree.MatrixDynSize___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.MatrixDynSize_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.MatrixDynSize_FromPython(_in)

# Register MatrixDynSize in _iDynTree:
_iDynTree.MatrixDynSize_swigregister(MatrixDynSize)

def MatrixDynSize_FromPython(_in):
    return _iDynTree.MatrixDynSize_FromPython(_in)

class SparseMatrixRowMajor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SparseMatrixRowMajor_swiginit(self, _iDynTree.new_SparseMatrixRowMajor(*args))
    __swig_destroy__ = _iDynTree.delete_SparseMatrixRowMajor

    def numberOfNonZeros(self):
        return _iDynTree.SparseMatrixRowMajor_numberOfNonZeros(self)

    def resize(self, *args):
        return _iDynTree.SparseMatrixRowMajor_resize(self, *args)

    def reserve(self, nonZeroElements):
        return _iDynTree.SparseMatrixRowMajor_reserve(self, nonZeroElements)

    def zero(self):
        return _iDynTree.SparseMatrixRowMajor_zero(self)

    def setFromConstTriplets(self, triplets):
        return _iDynTree.SparseMatrixRowMajor_setFromConstTriplets(self, triplets)

    def setFromTriplets(self, triplets):
        return _iDynTree.SparseMatrixRowMajor_setFromTriplets(self, triplets)

    @staticmethod
    def sparseMatrixFromTriplets(rows, cols, nonZeroElements):
        return _iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)

    def __call__(self, *args):
        return _iDynTree.SparseMatrixRowMajor___call__(self, *args)

    def getValue(self, row, col):
        return _iDynTree.SparseMatrixRowMajor_getValue(self, row, col)

    def setValue(self, row, col, newValue):
        return _iDynTree.SparseMatrixRowMajor_setValue(self, row, col, newValue)

    def rows(self):
        return _iDynTree.SparseMatrixRowMajor_rows(self)

    def columns(self):
        return _iDynTree.SparseMatrixRowMajor_columns(self)

    def description(self, fullMatrix=False):
        return _iDynTree.SparseMatrixRowMajor_description(self, fullMatrix)

# Register SparseMatrixRowMajor in _iDynTree:
_iDynTree.SparseMatrixRowMajor_swigregister(SparseMatrixRowMajor)

def SparseMatrixRowMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements):
    return _iDynTree.SparseMatrixRowMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)

class SparseMatrixColMajor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SparseMatrixColMajor_swiginit(self, _iDynTree.new_SparseMatrixColMajor(*args))
    __swig_destroy__ = _iDynTree.delete_SparseMatrixColMajor

    def numberOfNonZeros(self):
        return _iDynTree.SparseMatrixColMajor_numberOfNonZeros(self)

    def resize(self, *args):
        return _iDynTree.SparseMatrixColMajor_resize(self, *args)

    def reserve(self, nonZeroElements):
        return _iDynTree.SparseMatrixColMajor_reserve(self, nonZeroElements)

    def zero(self):
        return _iDynTree.SparseMatrixColMajor_zero(self)

    def setFromConstTriplets(self, triplets):
        return _iDynTree.SparseMatrixColMajor_setFromConstTriplets(self, triplets)

    def setFromTriplets(self, triplets):
        return _iDynTree.SparseMatrixColMajor_setFromTriplets(self, triplets)

    @staticmethod
    def sparseMatrixFromTriplets(rows, cols, nonZeroElements):
        return _iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)

    def __call__(self, *args):
        return _iDynTree.SparseMatrixColMajor___call__(self, *args)

    def getValue(self, row, col):
        return _iDynTree.SparseMatrixColMajor_getValue(self, row, col)

    def setValue(self, row, col, newValue):
        return _iDynTree.SparseMatrixColMajor_setValue(self, row, col, newValue)

    def rows(self):
        return _iDynTree.SparseMatrixColMajor_rows(self)

    def columns(self):
        return _iDynTree.SparseMatrixColMajor_columns(self)

    def description(self, fullMatrix=False):
        return _iDynTree.SparseMatrixColMajor_description(self, fullMatrix)

# Register SparseMatrixColMajor in _iDynTree:
_iDynTree.SparseMatrixColMajor_swigregister(SparseMatrixColMajor)

def SparseMatrixColMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements):
    return _iDynTree.SparseMatrixColMajor_sparseMatrixFromTriplets(rows, cols, nonZeroElements)

class VectorDynSize(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.VectorDynSize_swiginit(self, _iDynTree.new_VectorDynSize(*args))
    __swig_destroy__ = _iDynTree.delete_VectorDynSize

    def __call__(self, *args):
        return _iDynTree.VectorDynSize___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.VectorDynSize_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.VectorDynSize_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.VectorDynSize_cbegin(self)

    def cend(self):
        return _iDynTree.VectorDynSize_cend(self)

    def begin(self, *args):
        return _iDynTree.VectorDynSize_begin(self, *args)

    def end(self, *args):
        return _iDynTree.VectorDynSize_end(self, *args)

    def size(self):
        return _iDynTree.VectorDynSize_size(self)

    def data(self):
        return _iDynTree.VectorDynSize_data(self)

    def zero(self):
        return _iDynTree.VectorDynSize_zero(self)

    def reserve(self, newCapacity):
        return _iDynTree.VectorDynSize_reserve(self, newCapacity)

    def resize(self, newSize):
        return _iDynTree.VectorDynSize_resize(self, newSize)

    def shrink_to_fit(self):
        return _iDynTree.VectorDynSize_shrink_to_fit(self)

    def capacity(self):
        return _iDynTree.VectorDynSize_capacity(self)

    def fillBuffer(self, buf):
        return _iDynTree.VectorDynSize_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.VectorDynSize_toString(self)

    def __str__(self):
        return _iDynTree.VectorDynSize___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.VectorDynSize_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.VectorDynSize_FromPython(_in)

# Register VectorDynSize in _iDynTree:
_iDynTree.VectorDynSize_swigregister(VectorDynSize)

def VectorDynSize_FromPython(_in):
    return _iDynTree.VectorDynSize_FromPython(_in)

class Matrix1x6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix1x6_swiginit(self, _iDynTree.new_Matrix1x6(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix1x6___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix1x6_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix1x6_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix1x6_rows(self)

    def cols(self):
        return _iDynTree.Matrix1x6_cols(self)

    def data(self):
        return _iDynTree.Matrix1x6_data(self)

    def zero(self):
        return _iDynTree.Matrix1x6_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix1x6_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix1x6_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix1x6_toString(self)

    def __str__(self):
        return _iDynTree.Matrix1x6___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix1x6_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix1x6_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix1x6

# Register Matrix1x6 in _iDynTree:
_iDynTree.Matrix1x6_swigregister(Matrix1x6)

def Matrix1x6_FromPython(_in):
    return _iDynTree.Matrix1x6_FromPython(_in)

class Matrix2x3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix2x3_swiginit(self, _iDynTree.new_Matrix2x3(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix2x3___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix2x3_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix2x3_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix2x3_rows(self)

    def cols(self):
        return _iDynTree.Matrix2x3_cols(self)

    def data(self):
        return _iDynTree.Matrix2x3_data(self)

    def zero(self):
        return _iDynTree.Matrix2x3_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix2x3_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix2x3_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix2x3_toString(self)

    def __str__(self):
        return _iDynTree.Matrix2x3___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix2x3_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix2x3_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix2x3

# Register Matrix2x3 in _iDynTree:
_iDynTree.Matrix2x3_swigregister(Matrix2x3)

def Matrix2x3_FromPython(_in):
    return _iDynTree.Matrix2x3_FromPython(_in)

class Matrix3x3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix3x3_swiginit(self, _iDynTree.new_Matrix3x3(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix3x3___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix3x3_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix3x3_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix3x3_rows(self)

    def cols(self):
        return _iDynTree.Matrix3x3_cols(self)

    def data(self):
        return _iDynTree.Matrix3x3_data(self)

    def zero(self):
        return _iDynTree.Matrix3x3_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix3x3_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix3x3_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix3x3_toString(self)

    def __str__(self):
        return _iDynTree.Matrix3x3___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix3x3_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix3x3_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix3x3

# Register Matrix3x3 in _iDynTree:
_iDynTree.Matrix3x3_swigregister(Matrix3x3)

def Matrix3x3_FromPython(_in):
    return _iDynTree.Matrix3x3_FromPython(_in)

class Matrix4x4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix4x4_swiginit(self, _iDynTree.new_Matrix4x4(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix4x4___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix4x4_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix4x4_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix4x4_rows(self)

    def cols(self):
        return _iDynTree.Matrix4x4_cols(self)

    def data(self):
        return _iDynTree.Matrix4x4_data(self)

    def zero(self):
        return _iDynTree.Matrix4x4_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix4x4_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix4x4_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix4x4_toString(self)

    def __str__(self):
        return _iDynTree.Matrix4x4___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix4x4_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix4x4_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix4x4

# Register Matrix4x4 in _iDynTree:
_iDynTree.Matrix4x4_swigregister(Matrix4x4)

def Matrix4x4_FromPython(_in):
    return _iDynTree.Matrix4x4_FromPython(_in)

class Matrix6x6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix6x6_swiginit(self, _iDynTree.new_Matrix6x6(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix6x6___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix6x6_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix6x6_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix6x6_rows(self)

    def cols(self):
        return _iDynTree.Matrix6x6_cols(self)

    def data(self):
        return _iDynTree.Matrix6x6_data(self)

    def zero(self):
        return _iDynTree.Matrix6x6_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix6x6_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix6x6_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix6x6_toString(self)

    def __str__(self):
        return _iDynTree.Matrix6x6___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix6x6_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix6x6_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix6x6

# Register Matrix6x6 in _iDynTree:
_iDynTree.Matrix6x6_swigregister(Matrix6x6)

def Matrix6x6_FromPython(_in):
    return _iDynTree.Matrix6x6_FromPython(_in)

class Matrix6x10(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix6x10_swiginit(self, _iDynTree.new_Matrix6x10(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix6x10___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix6x10_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix6x10_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix6x10_rows(self)

    def cols(self):
        return _iDynTree.Matrix6x10_cols(self)

    def data(self):
        return _iDynTree.Matrix6x10_data(self)

    def zero(self):
        return _iDynTree.Matrix6x10_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix6x10_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix6x10_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix6x10_toString(self)

    def __str__(self):
        return _iDynTree.Matrix6x10___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix6x10_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix6x10_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix6x10

# Register Matrix6x10 in _iDynTree:
_iDynTree.Matrix6x10_swigregister(Matrix6x10)

def Matrix6x10_FromPython(_in):
    return _iDynTree.Matrix6x10_FromPython(_in)

class Matrix10x16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Matrix10x16_swiginit(self, _iDynTree.new_Matrix10x16(*args))

    def __call__(self, *args):
        return _iDynTree.Matrix10x16___call__(self, *args)

    def getVal(self, row, col):
        return _iDynTree.Matrix10x16_getVal(self, row, col)

    def setVal(self, row, col, new_el):
        return _iDynTree.Matrix10x16_setVal(self, row, col, new_el)

    def rows(self):
        return _iDynTree.Matrix10x16_rows(self)

    def cols(self):
        return _iDynTree.Matrix10x16_cols(self)

    def data(self):
        return _iDynTree.Matrix10x16_data(self)

    def zero(self):
        return _iDynTree.Matrix10x16_zero(self)

    def fillRowMajorBuffer(self, rowMajorBuf):
        return _iDynTree.Matrix10x16_fillRowMajorBuffer(self, rowMajorBuf)

    def fillColMajorBuffer(self, colMajorBuf):
        return _iDynTree.Matrix10x16_fillColMajorBuffer(self, colMajorBuf)

    def toString(self):
        return _iDynTree.Matrix10x16_toString(self)

    def __str__(self):
        return _iDynTree.Matrix10x16___str__(self)

    def __setitem__(self, indices, value):            
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        if not self.setVal(indices[0], indices[1], value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, indices):
        if not (len(indices) == 2 and indices[0] < self.rows() and indices[1] < self.cols()):
            raise IndexError(f"Indices {indices} not valid. The matrix has dimesions of ({self.rows()}, {self.cols()}).")

        return self.getVal(indices[0], indices[1])

    def __len__(self):
        return self.rows() * self.cols()


    def toNumPy(self):
        return _iDynTree.Matrix10x16_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Matrix10x16_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Matrix10x16

# Register Matrix10x16 in _iDynTree:
_iDynTree.Matrix10x16_swigregister(Matrix10x16)

def Matrix10x16_FromPython(_in):
    return _iDynTree.Matrix10x16_FromPython(_in)

class Vector3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Vector3_swiginit(self, _iDynTree.new_Vector3(*args))

    def __call__(self, *args):
        return _iDynTree.Vector3___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector3_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector3_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector3_cbegin(self)

    def cend(self):
        return _iDynTree.Vector3_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector3_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector3_end(self, *args)

    def size(self):
        return _iDynTree.Vector3_size(self)

    def data(self):
        return _iDynTree.Vector3_data(self)

    def zero(self):
        return _iDynTree.Vector3_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector3_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector3_toString(self)

    def __str__(self):
        return _iDynTree.Vector3___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector3_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Vector3_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Vector3

# Register Vector3 in _iDynTree:
_iDynTree.Vector3_swigregister(Vector3)

def Vector3_FromPython(_in):
    return _iDynTree.Vector3_FromPython(_in)

class Vector4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Vector4_swiginit(self, _iDynTree.new_Vector4(*args))

    def __call__(self, *args):
        return _iDynTree.Vector4___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector4_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector4_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector4_cbegin(self)

    def cend(self):
        return _iDynTree.Vector4_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector4_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector4_end(self, *args)

    def size(self):
        return _iDynTree.Vector4_size(self)

    def data(self):
        return _iDynTree.Vector4_data(self)

    def zero(self):
        return _iDynTree.Vector4_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector4_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector4_toString(self)

    def __str__(self):
        return _iDynTree.Vector4___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector4_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Vector4_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Vector4

# Register Vector4 in _iDynTree:
_iDynTree.Vector4_swigregister(Vector4)

def Vector4_FromPython(_in):
    return _iDynTree.Vector4_FromPython(_in)

class Vector6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Vector6_swiginit(self, _iDynTree.new_Vector6(*args))

    def __call__(self, *args):
        return _iDynTree.Vector6___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector6_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector6_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector6_cbegin(self)

    def cend(self):
        return _iDynTree.Vector6_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector6_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector6_end(self, *args)

    def size(self):
        return _iDynTree.Vector6_size(self)

    def data(self):
        return _iDynTree.Vector6_data(self)

    def zero(self):
        return _iDynTree.Vector6_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector6_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector6_toString(self)

    def __str__(self):
        return _iDynTree.Vector6___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector6_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Vector6_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Vector6

# Register Vector6 in _iDynTree:
_iDynTree.Vector6_swigregister(Vector6)

def Vector6_FromPython(_in):
    return _iDynTree.Vector6_FromPython(_in)

class Vector10(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Vector10_swiginit(self, _iDynTree.new_Vector10(*args))

    def __call__(self, *args):
        return _iDynTree.Vector10___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector10_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector10_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector10_cbegin(self)

    def cend(self):
        return _iDynTree.Vector10_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector10_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector10_end(self, *args)

    def size(self):
        return _iDynTree.Vector10_size(self)

    def data(self):
        return _iDynTree.Vector10_data(self)

    def zero(self):
        return _iDynTree.Vector10_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector10_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector10_toString(self)

    def __str__(self):
        return _iDynTree.Vector10___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector10_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Vector10_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Vector10

# Register Vector10 in _iDynTree:
_iDynTree.Vector10_swigregister(Vector10)

def Vector10_FromPython(_in):
    return _iDynTree.Vector10_FromPython(_in)

class Vector16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Vector16_swiginit(self, _iDynTree.new_Vector16(*args))

    def __call__(self, *args):
        return _iDynTree.Vector16___call__(self, *args)

    def getVal(self, index):
        return _iDynTree.Vector16_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.Vector16_setVal(self, index, new_el)

    def cbegin(self):
        return _iDynTree.Vector16_cbegin(self)

    def cend(self):
        return _iDynTree.Vector16_cend(self)

    def begin(self, *args):
        return _iDynTree.Vector16_begin(self, *args)

    def end(self, *args):
        return _iDynTree.Vector16_end(self, *args)

    def size(self):
        return _iDynTree.Vector16_size(self)

    def data(self):
        return _iDynTree.Vector16_data(self)

    def zero(self):
        return _iDynTree.Vector16_zero(self)

    def fillBuffer(self, buf):
        return _iDynTree.Vector16_fillBuffer(self, buf)

    def toString(self):
        return _iDynTree.Vector16_toString(self)

    def __str__(self):
        return _iDynTree.Vector16___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.Vector16_toNumPy(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Vector16_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Vector16

# Register Vector16 in _iDynTree:
_iDynTree.Vector16_swigregister(Vector16)

def Vector16_FromPython(_in):
    return _iDynTree.Vector16_FromPython(_in)

class PositionRaw(Vector3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.PositionRaw_swiginit(self, _iDynTree.new_PositionRaw(*args))

    def changePoint(self, newPoint):
        return _iDynTree.PositionRaw_changePoint(self, newPoint)

    def changeRefPoint(self, newRefPoint):
        return _iDynTree.PositionRaw_changeRefPoint(self, newRefPoint)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.PositionRaw_compose(op1, op2)

    @staticmethod
    def inverse(op):
        return _iDynTree.PositionRaw_inverse(op)

    def changePointOf(self, *args):
        return _iDynTree.PositionRaw_changePointOf(self, *args)

    def toString(self):
        return _iDynTree.PositionRaw_toString(self)

    def __str__(self):
        return _iDynTree.PositionRaw___str__(self)
    __swig_destroy__ = _iDynTree.delete_PositionRaw

# Register PositionRaw in _iDynTree:
_iDynTree.PositionRaw_swigregister(PositionRaw)

def PositionRaw_compose(op1, op2):
    return _iDynTree.PositionRaw_compose(op1, op2)

def PositionRaw_inverse(op):
    return _iDynTree.PositionRaw_inverse(op)

class Position(PositionRaw):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def changePoint(self, newPoint):
        return _iDynTree.Position_changePoint(self, newPoint)

    def changeRefPoint(self, newRefPoint):
        return _iDynTree.Position_changeRefPoint(self, newRefPoint)

    def changeCoordinateFrame(self, newCoordinateFrame):
        return _iDynTree.Position_changeCoordinateFrame(self, newCoordinateFrame)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.Position_compose(op1, op2)

    @staticmethod
    def inverse(op):
        return _iDynTree.Position_inverse(op)

    def changePointOf(self, *args):
        return _iDynTree.Position_changePointOf(self, *args)

    def __add__(self, other):
        return _iDynTree.Position___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Position___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Position___neg__(self)

    def __mul__(self, *args):
        return _iDynTree.Position___mul__(self, *args)

    def toString(self):
        return _iDynTree.Position_toString(self)

    def __str__(self):
        return _iDynTree.Position___str__(self)

    @staticmethod
    def Zero():
        return _iDynTree.Position_Zero()

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Position_FromPython(_in)

    def __init__(self, *args):
        _iDynTree.Position_swiginit(self, _iDynTree.new_Position(*args))
    __swig_destroy__ = _iDynTree.delete_Position

# Register Position in _iDynTree:
_iDynTree.Position_swigregister(Position)

def Position_compose(op1, op2):
    return _iDynTree.Position_compose(op1, op2)

def Position_inverse(op):
    return _iDynTree.Position_inverse(op)

def Position_Zero():
    return _iDynTree.Position_Zero()

def Position_FromPython(_in):
    return _iDynTree.Position_FromPython(_in)

class GeomVector3(Vector3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.GeomVector3_swiginit(self, _iDynTree.new_GeomVector3(*args))

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.GeomVector3_changeCoordFrame(self, newCoordFrame)

    def compose(self, op1, op2):
        return _iDynTree.GeomVector3_compose(self, op1, op2)

    def inverse(self, op):
        return _iDynTree.GeomVector3_inverse(self, op)

    def dot(self, other):
        return _iDynTree.GeomVector3_dot(self, other)

    def __add__(self, other):
        return _iDynTree.GeomVector3___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.GeomVector3___sub__(self, other)

    def __neg__(self):
        return _iDynTree.GeomVector3___neg__(self)

    def exp(self):
        return _iDynTree.GeomVector3_exp(self)

    def cross(self, other):
        return _iDynTree.GeomVector3_cross(self, other)
    __swig_destroy__ = _iDynTree.delete_GeomVector3

# Register GeomVector3 in _iDynTree:
_iDynTree.GeomVector3_swigregister(GeomVector3)

class SpatialMotionVectorBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialMotionVectorBase_swiginit(self, _iDynTree.new_SpatialMotionVectorBase(*args))

    def getLinearVec3(self):
        return _iDynTree.SpatialMotionVectorBase_getLinearVec3(self)

    def getAngularVec3(self):
        return _iDynTree.SpatialMotionVectorBase_getAngularVec3(self)

    def setLinearVec3(self, _linearVec3):
        return _iDynTree.SpatialMotionVectorBase_setLinearVec3(self, _linearVec3)

    def setAngularVec3(self, _angularVec3):
        return _iDynTree.SpatialMotionVectorBase_setAngularVec3(self, _angularVec3)

    def __call__(self, index):
        return _iDynTree.SpatialMotionVectorBase___call__(self, index)

    def getVal(self, index):
        return _iDynTree.SpatialMotionVectorBase_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.SpatialMotionVectorBase_setVal(self, index, new_el)

    def size(self):
        return _iDynTree.SpatialMotionVectorBase_size(self)

    def zero(self):
        return _iDynTree.SpatialMotionVectorBase_zero(self)

    def changePoint(self, newPoint):
        return _iDynTree.SpatialMotionVectorBase_changePoint(self, newPoint)

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.SpatialMotionVectorBase_changeCoordFrame(self, newCoordFrame)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.SpatialMotionVectorBase_compose(op1, op2)

    @staticmethod
    def inverse(op):
        return _iDynTree.SpatialMotionVectorBase_inverse(op)

    def dot(self, other):
        return _iDynTree.SpatialMotionVectorBase_dot(self, other)

    def __add__(self, other):
        return _iDynTree.SpatialMotionVectorBase___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialMotionVectorBase___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialMotionVectorBase___neg__(self)

    @staticmethod
    def Zero():
        return _iDynTree.SpatialMotionVectorBase_Zero()

    def asVector(self):
        return _iDynTree.SpatialMotionVectorBase_asVector(self)

    def toString(self):
        return _iDynTree.SpatialMotionVectorBase_toString(self)

    def __str__(self):
        return _iDynTree.SpatialMotionVectorBase___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.SpatialMotionVectorBase_toNumPy(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMotionVectorBase

# Register SpatialMotionVectorBase in _iDynTree:
_iDynTree.SpatialMotionVectorBase_swigregister(SpatialMotionVectorBase)

def SpatialMotionVectorBase_compose(op1, op2):
    return _iDynTree.SpatialMotionVectorBase_compose(op1, op2)

def SpatialMotionVectorBase_inverse(op):
    return _iDynTree.SpatialMotionVectorBase_inverse(op)

def SpatialMotionVectorBase_Zero():
    return _iDynTree.SpatialMotionVectorBase_Zero()

class SpatialForceVectorBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialForceVectorBase_swiginit(self, _iDynTree.new_SpatialForceVectorBase(*args))

    def getLinearVec3(self):
        return _iDynTree.SpatialForceVectorBase_getLinearVec3(self)

    def getAngularVec3(self):
        return _iDynTree.SpatialForceVectorBase_getAngularVec3(self)

    def setLinearVec3(self, _linearVec3):
        return _iDynTree.SpatialForceVectorBase_setLinearVec3(self, _linearVec3)

    def setAngularVec3(self, _angularVec3):
        return _iDynTree.SpatialForceVectorBase_setAngularVec3(self, _angularVec3)

    def __call__(self, index):
        return _iDynTree.SpatialForceVectorBase___call__(self, index)

    def getVal(self, index):
        return _iDynTree.SpatialForceVectorBase_getVal(self, index)

    def setVal(self, index, new_el):
        return _iDynTree.SpatialForceVectorBase_setVal(self, index, new_el)

    def size(self):
        return _iDynTree.SpatialForceVectorBase_size(self)

    def zero(self):
        return _iDynTree.SpatialForceVectorBase_zero(self)

    def changePoint(self, newPoint):
        return _iDynTree.SpatialForceVectorBase_changePoint(self, newPoint)

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.SpatialForceVectorBase_changeCoordFrame(self, newCoordFrame)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.SpatialForceVectorBase_compose(op1, op2)

    @staticmethod
    def inverse(op):
        return _iDynTree.SpatialForceVectorBase_inverse(op)

    def dot(self, other):
        return _iDynTree.SpatialForceVectorBase_dot(self, other)

    def __add__(self, other):
        return _iDynTree.SpatialForceVectorBase___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialForceVectorBase___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialForceVectorBase___neg__(self)

    @staticmethod
    def Zero():
        return _iDynTree.SpatialForceVectorBase_Zero()

    def asVector(self):
        return _iDynTree.SpatialForceVectorBase_asVector(self)

    def toString(self):
        return _iDynTree.SpatialForceVectorBase_toString(self)

    def __str__(self):
        return _iDynTree.SpatialForceVectorBase___str__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def toNumPy(self):
        return _iDynTree.SpatialForceVectorBase_toNumPy(self)
    __swig_destroy__ = _iDynTree.delete_SpatialForceVectorBase

# Register SpatialForceVectorBase in _iDynTree:
_iDynTree.SpatialForceVectorBase_swigregister(SpatialForceVectorBase)

def SpatialForceVectorBase_compose(op1, op2):
    return _iDynTree.SpatialForceVectorBase_compose(op1, op2)

def SpatialForceVectorBase_inverse(op):
    return _iDynTree.SpatialForceVectorBase_inverse(op)

def SpatialForceVectorBase_Zero():
    return _iDynTree.SpatialForceVectorBase_Zero()

class Dummy(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.Dummy_swiginit(self, _iDynTree.new_Dummy())
    __swig_destroy__ = _iDynTree.delete_Dummy

# Register Dummy in _iDynTree:
_iDynTree.Dummy_swigregister(Dummy)

class SpatialMotionVector(SpatialMotionVectorBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialMotionVector_swiginit(self, _iDynTree.new_SpatialMotionVector(*args))

    def __mul__(self, scalar):
        return _iDynTree.SpatialMotionVector___mul__(self, scalar)

    def cross(self, *args):
        return _iDynTree.SpatialMotionVector_cross(self, *args)

    def asCrossProductMatrix(self):
        return _iDynTree.SpatialMotionVector_asCrossProductMatrix(self)

    def asCrossProductMatrixWrench(self):
        return _iDynTree.SpatialMotionVector_asCrossProductMatrixWrench(self)

    def exp(self):
        return _iDynTree.SpatialMotionVector_exp(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMotionVector

# Register SpatialMotionVector in _iDynTree:
_iDynTree.SpatialMotionVector_swigregister(SpatialMotionVector)

class SpatialForceVector(SpatialForceVectorBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialForceVector_swiginit(self, _iDynTree.new_SpatialForceVector(*args))
    __swig_destroy__ = _iDynTree.delete_SpatialForceVector

    def __mul__(self, scalar):
        return _iDynTree.SpatialForceVector___mul__(self, scalar)

# Register SpatialForceVector in _iDynTree:
_iDynTree.SpatialForceVector_swigregister(SpatialForceVector)

class Twist(SpatialMotionVector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.Twist___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Twist___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Twist___neg__(self)

    def __mul__(self, *args):
        return _iDynTree.Twist___mul__(self, *args)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        _iDynTree.Twist_swiginit(self, _iDynTree.new_Twist(*args))

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Twist_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Twist

# Register Twist in _iDynTree:
_iDynTree.Twist_swigregister(Twist)

def Twist_FromPython(_in):
    return _iDynTree.Twist_FromPython(_in)

class Wrench(SpatialForceVector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.Wrench___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.Wrench___sub__(self, other)

    def __neg__(self):
        return _iDynTree.Wrench___neg__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        _iDynTree.Wrench_swiginit(self, _iDynTree.new_Wrench(*args))

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Wrench_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_Wrench

# Register Wrench in _iDynTree:
_iDynTree.Wrench_swigregister(Wrench)

def Wrench_FromPython(_in):
    return _iDynTree.Wrench_FromPython(_in)

class SpatialMomentum(SpatialForceVector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialMomentum_swiginit(self, _iDynTree.new_SpatialMomentum(*args))

    def __add__(self, other):
        return _iDynTree.SpatialMomentum___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialMomentum___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialMomentum___neg__(self)
    __swig_destroy__ = _iDynTree.delete_SpatialMomentum

# Register SpatialMomentum in _iDynTree:
_iDynTree.SpatialMomentum_swigregister(SpatialMomentum)

class SpatialAcc(SpatialMotionVector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __add__(self, other):
        return _iDynTree.SpatialAcc___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.SpatialAcc___sub__(self, other)

    def __neg__(self):
        return _iDynTree.SpatialAcc___neg__(self)

    def __setitem__(self, index, value):
        if index >= self.size():
            raise IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        if not self.setVal(index, value):
            raise RuntimeError("Failed to set the value")

    def __getitem__(self, index):
        if index >= self.size():
            IndexError(f"Index {index} not valid. The vector has a size of {self.size()}.")

        return self.getVal(index)

    def __len__(self):
        return self.size()


    def __init__(self, *args):
        _iDynTree.SpatialAcc_swiginit(self, _iDynTree.new_SpatialAcc(*args))

    @staticmethod
    def FromPython(_in):
        return _iDynTree.SpatialAcc_FromPython(_in)
    __swig_destroy__ = _iDynTree.delete_SpatialAcc

# Register SpatialAcc in _iDynTree:
_iDynTree.SpatialAcc_swigregister(SpatialAcc)

def SpatialAcc_FromPython(_in):
    return _iDynTree.SpatialAcc_FromPython(_in)

class ClassicalAcc(Vector6):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.ClassicalAcc_swiginit(self, _iDynTree.new_ClassicalAcc(*args))

    def changeCoordFrame(self, newCoordFrame):
        return _iDynTree.ClassicalAcc_changeCoordFrame(self, newCoordFrame)

    @staticmethod
    def Zero():
        return _iDynTree.ClassicalAcc_Zero()

    def fromSpatial(self, spatialAcc, vel):
        return _iDynTree.ClassicalAcc_fromSpatial(self, spatialAcc, vel)

    def toSpatial(self, spatialAcc, vel):
        return _iDynTree.ClassicalAcc_toSpatial(self, spatialAcc, vel)
    __swig_destroy__ = _iDynTree.delete_ClassicalAcc

# Register ClassicalAcc in _iDynTree:
_iDynTree.ClassicalAcc_swigregister(ClassicalAcc)

def ClassicalAcc_Zero():
    return _iDynTree.ClassicalAcc_Zero()

class Direction(Vector3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Direction_swiginit(self, _iDynTree.new_Direction(*args))

    def Normalize(self, *args):
        return _iDynTree.Direction_Normalize(self, *args)

    def isParallel(self, otherDirection, tolerance):
        return _iDynTree.Direction_isParallel(self, otherDirection, tolerance)

    def isPerpendicular(self, otherDirection, tolerance):
        return _iDynTree.Direction_isPerpendicular(self, otherDirection, tolerance)

    def reverse(self):
        return _iDynTree.Direction_reverse(self)

    def toString(self):
        return _iDynTree.Direction_toString(self)

    def __str__(self):
        return _iDynTree.Direction___str__(self)

    @staticmethod
    def Default():
        return _iDynTree.Direction_Default()
    __swig_destroy__ = _iDynTree.delete_Direction

# Register Direction in _iDynTree:
_iDynTree.Direction_swigregister(Direction)

def Direction_Default():
    return _iDynTree.Direction_Default()

class Axis(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Axis_swiginit(self, _iDynTree.new_Axis(*args))

    def getDirection(self):
        return _iDynTree.Axis_getDirection(self)

    def getOrigin(self):
        return _iDynTree.Axis_getOrigin(self)

    def setDirection(self, _direction):
        return _iDynTree.Axis_setDirection(self, _direction)

    def setOrigin(self, _position):
        return _iDynTree.Axis_setOrigin(self, _position)

    def getRotationTransform(self, theta):
        return _iDynTree.Axis_getRotationTransform(self, theta)

    def getRotationTransformDerivative(self, theta):
        return _iDynTree.Axis_getRotationTransformDerivative(self, theta)

    def getRotationTwist(self, dtheta):
        return _iDynTree.Axis_getRotationTwist(self, dtheta)

    def getRotationSpatialAcc(self, d2theta):
        return _iDynTree.Axis_getRotationSpatialAcc(self, d2theta)

    def getTranslationTransform(self, dist):
        return _iDynTree.Axis_getTranslationTransform(self, dist)

    def getTranslationTransformDerivative(self, arg2):
        return _iDynTree.Axis_getTranslationTransformDerivative(self, arg2)

    def getTranslationTwist(self, ddist):
        return _iDynTree.Axis_getTranslationTwist(self, ddist)

    def getTranslationSpatialAcc(self, d2dist):
        return _iDynTree.Axis_getTranslationSpatialAcc(self, d2dist)

    def isParallel(self, otherAxis, tolerance):
        return _iDynTree.Axis_isParallel(self, otherAxis, tolerance)

    def reverse(self):
        return _iDynTree.Axis_reverse(self)

    def toString(self):
        return _iDynTree.Axis_toString(self)

    def __str__(self):
        return _iDynTree.Axis___str__(self)
    __swig_destroy__ = _iDynTree.delete_Axis

# Register Axis in _iDynTree:
_iDynTree.Axis_swigregister(Axis)

class RotationalInertiaRaw(Matrix3x3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.RotationalInertiaRaw_swiginit(self, _iDynTree.new_RotationalInertiaRaw(*args))

    @staticmethod
    def Zero():
        return _iDynTree.RotationalInertiaRaw_Zero()
    __swig_destroy__ = _iDynTree.delete_RotationalInertiaRaw

# Register RotationalInertiaRaw in _iDynTree:
_iDynTree.RotationalInertiaRaw_swigregister(RotationalInertiaRaw)

def RotationalInertiaRaw_Zero():
    return _iDynTree.RotationalInertiaRaw_Zero()

class SpatialInertiaRaw(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialInertiaRaw_swiginit(self, _iDynTree.new_SpatialInertiaRaw(*args))

    def fromRotationalInertiaWrtCenterOfMass(self, mass, com, rotInertia):
        return _iDynTree.SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass(self, mass, com, rotInertia)

    def getMass(self):
        return _iDynTree.SpatialInertiaRaw_getMass(self)

    def getCenterOfMass(self):
        return _iDynTree.SpatialInertiaRaw_getCenterOfMass(self)

    def getRotationalInertiaWrtFrameOrigin(self):
        return _iDynTree.SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin(self)

    def getRotationalInertiaWrtCenterOfMass(self):
        return _iDynTree.SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass(self)

    @staticmethod
    def combine(op1, op2):
        return _iDynTree.SpatialInertiaRaw_combine(op1, op2)

    def multiply(self, op):
        return _iDynTree.SpatialInertiaRaw_multiply(self, op)

    def zero(self):
        return _iDynTree.SpatialInertiaRaw_zero(self)
    __swig_destroy__ = _iDynTree.delete_SpatialInertiaRaw

# Register SpatialInertiaRaw in _iDynTree:
_iDynTree.SpatialInertiaRaw_swigregister(SpatialInertiaRaw)

def SpatialInertiaRaw_combine(op1, op2):
    return _iDynTree.SpatialInertiaRaw_combine(op1, op2)

class SpatialInertia(SpatialInertiaRaw):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SpatialInertia_swiginit(self, _iDynTree.new_SpatialInertia(*args))

    @staticmethod
    def combine(op1, op2):
        return _iDynTree.SpatialInertia_combine(op1, op2)

    def asMatrix(self):
        return _iDynTree.SpatialInertia_asMatrix(self)

    def applyInverse(self, mom):
        return _iDynTree.SpatialInertia_applyInverse(self, mom)

    def getInverse(self):
        return _iDynTree.SpatialInertia_getInverse(self)

    def __add__(self, other):
        return _iDynTree.SpatialInertia___add__(self, other)

    def __mul__(self, *args):
        return _iDynTree.SpatialInertia___mul__(self, *args)

    def biasWrench(self, V):
        return _iDynTree.SpatialInertia_biasWrench(self, V)

    def biasWrenchDerivative(self, V):
        return _iDynTree.SpatialInertia_biasWrenchDerivative(self, V)

    @staticmethod
    def Zero():
        return _iDynTree.SpatialInertia_Zero()

    def asVector(self):
        return _iDynTree.SpatialInertia_asVector(self)

    def fromVector(self, inertialParams):
        return _iDynTree.SpatialInertia_fromVector(self, inertialParams)

    def isPhysicallyConsistent(self):
        return _iDynTree.SpatialInertia_isPhysicallyConsistent(self)

    @staticmethod
    def momentumRegressor(v):
        return _iDynTree.SpatialInertia_momentumRegressor(v)

    @staticmethod
    def momentumDerivativeRegressor(v, a):
        return _iDynTree.SpatialInertia_momentumDerivativeRegressor(v, a)

    @staticmethod
    def momentumDerivativeSlotineLiRegressor(v, vRef, aRef):
        return _iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor(v, vRef, aRef)
    __swig_destroy__ = _iDynTree.delete_SpatialInertia

# Register SpatialInertia in _iDynTree:
_iDynTree.SpatialInertia_swigregister(SpatialInertia)

def SpatialInertia_combine(op1, op2):
    return _iDynTree.SpatialInertia_combine(op1, op2)

def SpatialInertia_Zero():
    return _iDynTree.SpatialInertia_Zero()

def SpatialInertia_momentumRegressor(v):
    return _iDynTree.SpatialInertia_momentumRegressor(v)

def SpatialInertia_momentumDerivativeRegressor(v, a):
    return _iDynTree.SpatialInertia_momentumDerivativeRegressor(v, a)

def SpatialInertia_momentumDerivativeSlotineLiRegressor(v, vRef, aRef):
    return _iDynTree.SpatialInertia_momentumDerivativeSlotineLiRegressor(v, vRef, aRef)

class ArticulatedBodyInertia(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.ArticulatedBodyInertia_swiginit(self, _iDynTree.new_ArticulatedBodyInertia(*args))

    def getLinearLinearSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getLinearLinearSubmatrix(self, *args)

    def getLinearAngularSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getLinearAngularSubmatrix(self, *args)

    def getAngularAngularSubmatrix(self, *args):
        return _iDynTree.ArticulatedBodyInertia_getAngularAngularSubmatrix(self, *args)

    @staticmethod
    def combine(op1, op2):
        return _iDynTree.ArticulatedBodyInertia_combine(op1, op2)

    def applyInverse(self, wrench):
        return _iDynTree.ArticulatedBodyInertia_applyInverse(self, wrench)

    def asMatrix(self):
        return _iDynTree.ArticulatedBodyInertia_asMatrix(self)

    def getInverse(self):
        return _iDynTree.ArticulatedBodyInertia_getInverse(self)

    def __add__(self, other):
        return _iDynTree.ArticulatedBodyInertia___add__(self, other)

    def __sub__(self, other):
        return _iDynTree.ArticulatedBodyInertia___sub__(self, other)

    def __mul__(self, *args):
        return _iDynTree.ArticulatedBodyInertia___mul__(self, *args)

    def zero(self):
        return _iDynTree.ArticulatedBodyInertia_zero(self)

    @staticmethod
    def ABADyadHelper(U, d):
        return _iDynTree.ArticulatedBodyInertia_ABADyadHelper(U, d)

    @staticmethod
    def ABADyadHelperLin(U, inv_d, dU, d_inv_d):
        return _iDynTree.ArticulatedBodyInertia_ABADyadHelperLin(U, inv_d, dU, d_inv_d)
    __swig_destroy__ = _iDynTree.delete_ArticulatedBodyInertia

# Register ArticulatedBodyInertia in _iDynTree:
_iDynTree.ArticulatedBodyInertia_swigregister(ArticulatedBodyInertia)

def ArticulatedBodyInertia_combine(op1, op2):
    return _iDynTree.ArticulatedBodyInertia_combine(op1, op2)

def ArticulatedBodyInertia_ABADyadHelper(U, d):
    return _iDynTree.ArticulatedBodyInertia_ABADyadHelper(U, d)

def ArticulatedBodyInertia_ABADyadHelperLin(U, inv_d, dU, d_inv_d):
    return _iDynTree.ArticulatedBodyInertia_ABADyadHelperLin(U, inv_d, dU, d_inv_d)

class RigidBodyInertiaNonLinearParametrization(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mass = property(_iDynTree.RigidBodyInertiaNonLinearParametrization_mass_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_mass_set)
    com = property(_iDynTree.RigidBodyInertiaNonLinearParametrization_com_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_com_set)
    link_R_centroidal = property(_iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set)
    centralSecondMomentOfMass = property(_iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get, _iDynTree.RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set)

    def getLinkCentroidalTransform(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform(self)

    def fromRigidBodyInertia(self, inertia):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia(self, inertia)

    def fromInertialParameters(self, inertialParams):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromInertialParameters(self, inertialParams)

    def toRigidBodyInertia(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia(self)

    def isPhysicallyConsistent(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent(self)

    def asVectorWithRotationAsVec(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec(self)

    def fromVectorWithRotationAsVec(self, vec):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec(self, vec)

    def getGradientWithRotationAsVec(self):
        return _iDynTree.RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec(self)

    def __init__(self):
        _iDynTree.RigidBodyInertiaNonLinearParametrization_swiginit(self, _iDynTree.new_RigidBodyInertiaNonLinearParametrization())
    __swig_destroy__ = _iDynTree.delete_RigidBodyInertiaNonLinearParametrization

# Register RigidBodyInertiaNonLinearParametrization in _iDynTree:
_iDynTree.RigidBodyInertiaNonLinearParametrization_swigregister(RigidBodyInertiaNonLinearParametrization)

class RotationRaw(Matrix3x3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.RotationRaw_swiginit(self, _iDynTree.new_RotationRaw(*args))

    def changeOrientFrame(self, newOrientFrame):
        return _iDynTree.RotationRaw_changeOrientFrame(self, newOrientFrame)

    def changeRefOrientFrame(self, newRefOrientFrame):
        return _iDynTree.RotationRaw_changeRefOrientFrame(self, newRefOrientFrame)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.RotationRaw_compose(op1, op2)

    @staticmethod
    def inverse2(orient):
        return _iDynTree.RotationRaw_inverse2(orient)

    def changeCoordFrameOf(self, *args):
        return _iDynTree.RotationRaw_changeCoordFrameOf(self, *args)

    @staticmethod
    def RotX(angle):
        return _iDynTree.RotationRaw_RotX(angle)

    @staticmethod
    def RotY(angle):
        return _iDynTree.RotationRaw_RotY(angle)

    @staticmethod
    def RotZ(angle):
        return _iDynTree.RotationRaw_RotZ(angle)

    @staticmethod
    def RPY(roll, pitch, yaw):
        return _iDynTree.RotationRaw_RPY(roll, pitch, yaw)

    @staticmethod
    def Identity():
        return _iDynTree.RotationRaw_Identity()

    def toString(self):
        return _iDynTree.RotationRaw_toString(self)

    def __str__(self):
        return _iDynTree.RotationRaw___str__(self)
    __swig_destroy__ = _iDynTree.delete_RotationRaw

# Register RotationRaw in _iDynTree:
_iDynTree.RotationRaw_swigregister(RotationRaw)

def RotationRaw_compose(op1, op2):
    return _iDynTree.RotationRaw_compose(op1, op2)

def RotationRaw_inverse2(orient):
    return _iDynTree.RotationRaw_inverse2(orient)

def RotationRaw_RotX(angle):
    return _iDynTree.RotationRaw_RotX(angle)

def RotationRaw_RotY(angle):
    return _iDynTree.RotationRaw_RotY(angle)

def RotationRaw_RotZ(angle):
    return _iDynTree.RotationRaw_RotZ(angle)

def RotationRaw_RPY(roll, pitch, yaw):
    return _iDynTree.RotationRaw_RPY(roll, pitch, yaw)

def RotationRaw_Identity():
    return _iDynTree.RotationRaw_Identity()

class Rotation(RotationRaw):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def changeOrientFrame(self, newOrientFrame):
        return _iDynTree.Rotation_changeOrientFrame(self, newOrientFrame)

    def changeRefOrientFrame(self, newRefOrientFrame):
        return _iDynTree.Rotation_changeRefOrientFrame(self, newRefOrientFrame)

    def changeCoordinateFrame(self, newCoordinateFrame):
        return _iDynTree.Rotation_changeCoordinateFrame(self, newCoordinateFrame)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.Rotation_compose(op1, op2)

    @staticmethod
    def inverse2(orient):
        return _iDynTree.Rotation_inverse2(orient)

    def changeCoordFrameOf(self, *args):
        return _iDynTree.Rotation_changeCoordFrameOf(self, *args)

    def inverse(self):
        return _iDynTree.Rotation_inverse(self)

    def __mul__(self, *args):
        return _iDynTree.Rotation___mul__(self, *args)

    def log(self):
        return _iDynTree.Rotation_log(self)

    def fromQuaternion(self, quaternion):
        return _iDynTree.Rotation_fromQuaternion(self, quaternion)

    def getRPY(self, r, p, y):
        return _iDynTree.Rotation_getRPY(self, r, p, y)

    def asRPY(self):
        return _iDynTree.Rotation_asRPY(self)

    def getQuaternion(self, *args):
        return _iDynTree.Rotation_getQuaternion(self, *args)

    def asQuaternion(self):
        return _iDynTree.Rotation_asQuaternion(self)

    @staticmethod
    def RotX(angle):
        return _iDynTree.Rotation_RotX(angle)

    @staticmethod
    def RotY(angle):
        return _iDynTree.Rotation_RotY(angle)

    @staticmethod
    def RotZ(angle):
        return _iDynTree.Rotation_RotZ(angle)

    @staticmethod
    def RotAxis(direction, angle):
        return _iDynTree.Rotation_RotAxis(direction, angle)

    @staticmethod
    def RotAxisDerivative(direction, angle):
        return _iDynTree.Rotation_RotAxisDerivative(direction, angle)

    @staticmethod
    def RPY(roll, pitch, yaw):
        return _iDynTree.Rotation_RPY(roll, pitch, yaw)

    @staticmethod
    def RPYRightTrivializedDerivative(roll, pitch, yaw):
        return _iDynTree.Rotation_RPYRightTrivializedDerivative(roll, pitch, yaw)

    @staticmethod
    def RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
        return _iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)

    @staticmethod
    def RPYRightTrivializedDerivativeInverse(roll, pitch, yaw):
        return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverse(roll, pitch, yaw)

    @staticmethod
    def RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
        return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)

    @staticmethod
    def QuaternionRightTrivializedDerivative(quaternion):
        return _iDynTree.Rotation_QuaternionRightTrivializedDerivative(quaternion)

    @staticmethod
    def QuaternionRightTrivializedDerivativeInverse(quaternion):
        return _iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse(quaternion)

    @staticmethod
    def Identity():
        return _iDynTree.Rotation_Identity()

    @staticmethod
    def RotationFromQuaternion(quaternion):
        return _iDynTree.Rotation_RotationFromQuaternion(quaternion)

    @staticmethod
    def leftJacobian(omega):
        return _iDynTree.Rotation_leftJacobian(omega)

    @staticmethod
    def leftJacobianInverse(omega):
        return _iDynTree.Rotation_leftJacobianInverse(omega)

    def toString(self):
        return _iDynTree.Rotation_toString(self)

    def __str__(self):
        return _iDynTree.Rotation___str__(self)

    @staticmethod
    def FromPython(_in):
        return _iDynTree.Rotation_FromPython(_in)

    def __init__(self, *args):
        _iDynTree.Rotation_swiginit(self, _iDynTree.new_Rotation(*args))
    __swig_destroy__ = _iDynTree.delete_Rotation

# Register Rotation in _iDynTree:
_iDynTree.Rotation_swigregister(Rotation)

def Rotation_compose(op1, op2):
    return _iDynTree.Rotation_compose(op1, op2)

def Rotation_inverse2(orient):
    return _iDynTree.Rotation_inverse2(orient)

def Rotation_RotX(angle):
    return _iDynTree.Rotation_RotX(angle)

def Rotation_RotY(angle):
    return _iDynTree.Rotation_RotY(angle)

def Rotation_RotZ(angle):
    return _iDynTree.Rotation_RotZ(angle)

def Rotation_RotAxis(direction, angle):
    return _iDynTree.Rotation_RotAxis(direction, angle)

def Rotation_RotAxisDerivative(direction, angle):
    return _iDynTree.Rotation_RotAxisDerivative(direction, angle)

def Rotation_RPY(roll, pitch, yaw):
    return _iDynTree.Rotation_RPY(roll, pitch, yaw)

def Rotation_RPYRightTrivializedDerivative(roll, pitch, yaw):
    return _iDynTree.Rotation_RPYRightTrivializedDerivative(roll, pitch, yaw)

def Rotation_RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)

def Rotation_RPYRightTrivializedDerivativeInverse(roll, pitch, yaw):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverse(roll, pitch, yaw)

def Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot):
    return _iDynTree.Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(roll, pitch, yaw, rollDot, pitchDot, yawDot)

def Rotation_QuaternionRightTrivializedDerivative(quaternion):
    return _iDynTree.Rotation_QuaternionRightTrivializedDerivative(quaternion)

def Rotation_QuaternionRightTrivializedDerivativeInverse(quaternion):
    return _iDynTree.Rotation_QuaternionRightTrivializedDerivativeInverse(quaternion)

def Rotation_Identity():
    return _iDynTree.Rotation_Identity()

def Rotation_RotationFromQuaternion(quaternion):
    return _iDynTree.Rotation_RotationFromQuaternion(quaternion)

def Rotation_leftJacobian(omega):
    return _iDynTree.Rotation_leftJacobian(omega)

def Rotation_leftJacobianInverse(omega):
    return _iDynTree.Rotation_leftJacobianInverse(omega)

def Rotation_FromPython(_in):
    return _iDynTree.Rotation_FromPython(_in)

class Transform(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Transform_swiginit(self, _iDynTree.new_Transform(*args))

    def fromHomogeneousTransform(self, transform):
        return _iDynTree.Transform_fromHomogeneousTransform(self, transform)

    def getRotation(self):
        return _iDynTree.Transform_getRotation(self)

    def getPosition(self):
        return _iDynTree.Transform_getPosition(self)

    @staticmethod
    def compose(op1, op2):
        return _iDynTree.Transform_compose(op1, op2)

    @staticmethod
    def inverse2(trans):
        return _iDynTree.Transform_inverse2(trans)

    def inverse(self):
        return _iDynTree.Transform_inverse(self)

    def __mul__(self, *args):
        return _iDynTree.Transform___mul__(self, *args)

    @staticmethod
    def Identity():
        return _iDynTree.Transform_Identity()

    def asHomogeneousTransform(self):
        return _iDynTree.Transform_asHomogeneousTransform(self)

    def asAdjointTransform(self):
        return _iDynTree.Transform_asAdjointTransform(self)

    def asAdjointTransformWrench(self):
        return _iDynTree.Transform_asAdjointTransformWrench(self)

    def log(self):
        return _iDynTree.Transform_log(self)

    def toString(self):
        return _iDynTree.Transform_toString(self)

    def __str__(self):
        return _iDynTree.Transform___str__(self)

    def setPosition(self, *args):
        return _iDynTree.Transform_setPosition(self, *args)

    def setRotation(self, *args):
        return _iDynTree.Transform_setRotation(self, *args)
    __swig_destroy__ = _iDynTree.delete_Transform

# Register Transform in _iDynTree:
_iDynTree.Transform_swigregister(Transform)

def Transform_compose(op1, op2):
    return _iDynTree.Transform_compose(op1, op2)

def Transform_inverse2(trans):
    return _iDynTree.Transform_inverse2(trans)

def Transform_Identity():
    return _iDynTree.Transform_Identity()

class TransformDerivative(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.TransformDerivative_swiginit(self, _iDynTree.new_TransformDerivative(*args))
    __swig_destroy__ = _iDynTree.delete_TransformDerivative

    def getRotationDerivative(self):
        return _iDynTree.TransformDerivative_getRotationDerivative(self)

    def getPositionDerivative(self):
        return _iDynTree.TransformDerivative_getPositionDerivative(self)

    def setRotationDerivative(self, rotationDerivative):
        return _iDynTree.TransformDerivative_setRotationDerivative(self, rotationDerivative)

    def setPositionDerivative(self, positionDerivative):
        return _iDynTree.TransformDerivative_setPositionDerivative(self, positionDerivative)

    @staticmethod
    def Zero():
        return _iDynTree.TransformDerivative_Zero()

    def asHomogeneousTransformDerivative(self):
        return _iDynTree.TransformDerivative_asHomogeneousTransformDerivative(self)

    def asAdjointTransformDerivative(self, transform):
        return _iDynTree.TransformDerivative_asAdjointTransformDerivative(self, transform)

    def asAdjointTransformWrenchDerivative(self, transform):
        return _iDynTree.TransformDerivative_asAdjointTransformWrenchDerivative(self, transform)

    def __mul__(self, otherTransform):
        return _iDynTree.TransformDerivative___mul__(self, otherTransform)

    def derivativeOfInverse(self, transform):
        return _iDynTree.TransformDerivative_derivativeOfInverse(self, transform)

    def transform(self, *args):
        return _iDynTree.TransformDerivative_transform(self, *args)

# Register TransformDerivative in _iDynTree:
_iDynTree.TransformDerivative_swigregister(TransformDerivative)

def TransformDerivative_Zero():
    return _iDynTree.TransformDerivative_Zero()

class DynamicSpan(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.DynamicSpan_swiginit(self, _iDynTree.new_DynamicSpan(*args))
    __swig_destroy__ = _iDynTree.delete_DynamicSpan

    def first(self, count):
        return _iDynTree.DynamicSpan_first(self, count)

    def last(self, count):
        return _iDynTree.DynamicSpan_last(self, count)

    def subspan(self, *args):
        return _iDynTree.DynamicSpan_subspan(self, *args)

    def size(self):
        return _iDynTree.DynamicSpan_size(self)

    def size_bytes(self):
        return _iDynTree.DynamicSpan_size_bytes(self)

    def empty(self):
        return _iDynTree.DynamicSpan_empty(self)

    def getVal(self, idx):
        return _iDynTree.DynamicSpan_getVal(self, idx)

    def setVal(self, idx, val):
        return _iDynTree.DynamicSpan_setVal(self, idx, val)

    def at(self, idx):
        return _iDynTree.DynamicSpan_at(self, idx)

    def __call__(self, idx):
        return _iDynTree.DynamicSpan___call__(self, idx)

    def begin(self):
        return _iDynTree.DynamicSpan_begin(self)

    def end(self):
        return _iDynTree.DynamicSpan_end(self)

    def cbegin(self):
        return _iDynTree.DynamicSpan_cbegin(self)

    def cend(self):
        return _iDynTree.DynamicSpan_cend(self)

    def rbegin(self):
        return _iDynTree.DynamicSpan_rbegin(self)

    def rend(self):
        return _iDynTree.DynamicSpan_rend(self)

    def crbegin(self):
        return _iDynTree.DynamicSpan_crbegin(self)

    def crend(self):
        return _iDynTree.DynamicSpan_crend(self)

# Register DynamicSpan in _iDynTree:
_iDynTree.DynamicSpan_swigregister(DynamicSpan)
cvar = _iDynTree.cvar
dynamic_extent = cvar.dynamic_extent
DynamicSpan.extent = _iDynTree.cvar.DynamicSpan_extent

class DynamicMatrixView(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.DynamicMatrixView_swiginit(self, _iDynTree.new_DynamicMatrixView(*args))

    def storageOrder(self):
        return _iDynTree.DynamicMatrixView_storageOrder(self)

    def __call__(self, row, col):
        return _iDynTree.DynamicMatrixView___call__(self, row, col)

    def rows(self):
        return _iDynTree.DynamicMatrixView_rows(self)

    def cols(self):
        return _iDynTree.DynamicMatrixView_cols(self)

    def block(self, startingRow, startingColumn, rows, cols):
        return _iDynTree.DynamicMatrixView_block(self, startingRow, startingColumn, rows, cols)
    __swig_destroy__ = _iDynTree.delete_DynamicMatrixView

# Register DynamicMatrixView in _iDynTree:
_iDynTree.DynamicMatrixView_swigregister(DynamicMatrixView)

class LinkPositions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkPositions_swiginit(self, _iDynTree.new_LinkPositions(*args))

    def resize(self, *args):
        return _iDynTree.LinkPositions_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkPositions_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkPositions_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkPositions___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkPositions_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkPositions

    def __getitem__(self, index):
        return _iDynTree.LinkPositions___getitem__(self, index)

    def __setitem__(self, index, element):
        return _iDynTree.LinkPositions___setitem__(self, index, element)

    def __len__(self):
        return self.getNrOfLinks()


# Register LinkPositions in _iDynTree:
_iDynTree.LinkPositions_swigregister(LinkPositions)

class LinkWrenches(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkWrenches_swiginit(self, _iDynTree.new_LinkWrenches(*args))

    def resize(self, *args):
        return _iDynTree.LinkWrenches_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkWrenches_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkWrenches_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkWrenches___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkWrenches_toString(self, model)

    def zero(self):
        return _iDynTree.LinkWrenches_zero(self)
    __swig_destroy__ = _iDynTree.delete_LinkWrenches

    def __getitem__(self, index):
        return _iDynTree.LinkWrenches___getitem__(self, index)

    def __setitem__(self, index, element):
        return _iDynTree.LinkWrenches___setitem__(self, index, element)

    def __len__(self):
        return self.getNrOfLinks()


# Register LinkWrenches in _iDynTree:
_iDynTree.LinkWrenches_swigregister(LinkWrenches)

class LinkInertias(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkInertias_swiginit(self, _iDynTree.new_LinkInertias(*args))

    def resize(self, *args):
        return _iDynTree.LinkInertias_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkInertias_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkInertias___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_LinkInertias

# Register LinkInertias in _iDynTree:
_iDynTree.LinkInertias_swigregister(LinkInertias)

class LinkArticulatedBodyInertias(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkArticulatedBodyInertias_swiginit(self, _iDynTree.new_LinkArticulatedBodyInertias(*args))

    def resize(self, *args):
        return _iDynTree.LinkArticulatedBodyInertias_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkArticulatedBodyInertias_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkArticulatedBodyInertias___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_LinkArticulatedBodyInertias

# Register LinkArticulatedBodyInertias in _iDynTree:
_iDynTree.LinkArticulatedBodyInertias_swigregister(LinkArticulatedBodyInertias)

class LinkVelArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkVelArray_swiginit(self, _iDynTree.new_LinkVelArray(*args))

    def resize(self, *args):
        return _iDynTree.LinkVelArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkVelArray_isConsistent(self, model)

    def getNrOfLinks(self):
        return _iDynTree.LinkVelArray_getNrOfLinks(self)

    def __call__(self, *args):
        return _iDynTree.LinkVelArray___call__(self, *args)

    def toString(self, model):
        return _iDynTree.LinkVelArray_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkVelArray

    def __getitem__(self, index):
        return _iDynTree.LinkVelArray___getitem__(self, index)

    def __setitem__(self, index, element):
        return _iDynTree.LinkVelArray___setitem__(self, index, element)

    def __len__(self):
        return self.getNrOfLinks()


# Register LinkVelArray in _iDynTree:
_iDynTree.LinkVelArray_swigregister(LinkVelArray)

class LinkAccArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkAccArray_swiginit(self, _iDynTree.new_LinkAccArray(*args))

    def resize(self, *args):
        return _iDynTree.LinkAccArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.LinkAccArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.LinkAccArray___call__(self, *args)

    def getNrOfLinks(self):
        return _iDynTree.LinkAccArray_getNrOfLinks(self)

    def toString(self, model):
        return _iDynTree.LinkAccArray_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkAccArray

    def __getitem__(self, index):
        return _iDynTree.LinkAccArray___getitem__(self, index)

    def __setitem__(self, index, element):
        return _iDynTree.LinkAccArray___setitem__(self, index, element)

    def __len__(self):
        return self.getNrOfLinks()


# Register LinkAccArray in _iDynTree:
_iDynTree.LinkAccArray_swigregister(LinkAccArray)

class Link(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.Link_swiginit(self, _iDynTree.new_Link())

    def inertia(self, *args):
        return _iDynTree.Link_inertia(self, *args)

    def setInertia(self, _inertia):
        return _iDynTree.Link_setInertia(self, _inertia)

    def getInertia(self):
        return _iDynTree.Link_getInertia(self)

    def setIndex(self, _index):
        return _iDynTree.Link_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.Link_getIndex(self)
    __swig_destroy__ = _iDynTree.delete_Link

# Register Link in _iDynTree:
_iDynTree.Link_swigregister(Link)

class IJoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IJoint

    def clone(self):
        return _iDynTree.IJoint_clone(self)

    def getNrOfPosCoords(self):
        return _iDynTree.IJoint_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.IJoint_getNrOfDOFs(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.IJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.IJoint_setRestTransform(self, link1_X_link2)

    def getFirstAttachedLink(self):
        return _iDynTree.IJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.IJoint_getSecondAttachedLink(self)

    def getRestTransform(self, child, parent):
        return _iDynTree.IJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.IJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.IJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, dof_i, child, parent):
        return _iDynTree.IJoint_getMotionSubspaceVector(self, dof_i, child, parent)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.IJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.IJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.IJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.IJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def setIndex(self, _index):
        return _iDynTree.IJoint_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.IJoint_getIndex(self)

    def setPosCoordsOffset(self, _index):
        return _iDynTree.IJoint_setPosCoordsOffset(self, _index)

    def getPosCoordsOffset(self):
        return _iDynTree.IJoint_getPosCoordsOffset(self)

    def setDOFsOffset(self, _index):
        return _iDynTree.IJoint_setDOFsOffset(self, _index)

    def getDOFsOffset(self):
        return _iDynTree.IJoint_getDOFsOffset(self)

    def hasPosLimits(self):
        return _iDynTree.IJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.IJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.IJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.IJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.IJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.IJoint_setPosLimits(self, _index, min, max)

    def isRevoluteJoint(self):
        return _iDynTree.IJoint_isRevoluteJoint(self)

    def isFixedJoint(self):
        return _iDynTree.IJoint_isFixedJoint(self)

    def isPrismaticJoint(self):
        return _iDynTree.IJoint_isPrismaticJoint(self)

    def asRevoluteJoint(self):
        return _iDynTree.IJoint_asRevoluteJoint(self)

    def asFixedJoint(self):
        return _iDynTree.IJoint_asFixedJoint(self)

    def asPrismaticJoint(self):
        return _iDynTree.IJoint_asPrismaticJoint(self)

# Register IJoint in _iDynTree:
_iDynTree.IJoint_swigregister(IJoint)

class FixedJoint(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FixedJoint_swiginit(self, _iDynTree.new_FixedJoint(*args))
    __swig_destroy__ = _iDynTree.delete_FixedJoint

    def clone(self):
        return _iDynTree.FixedJoint_clone(self)

    def getNrOfPosCoords(self):
        return _iDynTree.FixedJoint_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.FixedJoint_getNrOfDOFs(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.FixedJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.FixedJoint_setRestTransform(self, link1_X_link2)

    def getFirstAttachedLink(self):
        return _iDynTree.FixedJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.FixedJoint_getSecondAttachedLink(self)

    def getRestTransform(self, child, parent):
        return _iDynTree.FixedJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.FixedJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.FixedJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, dof_i, child, parent):
        return _iDynTree.FixedJoint_getMotionSubspaceVector(self, dof_i, child, parent)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.FixedJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.FixedJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.FixedJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def setIndex(self, _index):
        return _iDynTree.FixedJoint_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.FixedJoint_getIndex(self)

    def setPosCoordsOffset(self, _index):
        return _iDynTree.FixedJoint_setPosCoordsOffset(self, _index)

    def getPosCoordsOffset(self):
        return _iDynTree.FixedJoint_getPosCoordsOffset(self)

    def setDOFsOffset(self, _index):
        return _iDynTree.FixedJoint_setDOFsOffset(self, _index)

    def getDOFsOffset(self):
        return _iDynTree.FixedJoint_getDOFsOffset(self)

    def hasPosLimits(self):
        return _iDynTree.FixedJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.FixedJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.FixedJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.FixedJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.FixedJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.FixedJoint_setPosLimits(self, _index, min, max)

# Register FixedJoint in _iDynTree:
_iDynTree.FixedJoint_swigregister(FixedJoint)

class MovableJointImpl1(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl1

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl1_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl1_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl1_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl1_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl1_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl1_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl1_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl1_getDOFsOffset(self)

# Register MovableJointImpl1 in _iDynTree:
_iDynTree.MovableJointImpl1_swigregister(MovableJointImpl1)

class MovableJointImpl2(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl2

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl2_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl2_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl2_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl2_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl2_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl2_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl2_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl2_getDOFsOffset(self)

# Register MovableJointImpl2 in _iDynTree:
_iDynTree.MovableJointImpl2_swigregister(MovableJointImpl2)

class MovableJointImpl3(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl3

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl3_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl3_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl3_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl3_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl3_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl3_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl3_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl3_getDOFsOffset(self)

# Register MovableJointImpl3 in _iDynTree:
_iDynTree.MovableJointImpl3_swigregister(MovableJointImpl3)

class MovableJointImpl4(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl4

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl4_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl4_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl4_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl4_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl4_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl4_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl4_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl4_getDOFsOffset(self)

# Register MovableJointImpl4 in _iDynTree:
_iDynTree.MovableJointImpl4_swigregister(MovableJointImpl4)

class MovableJointImpl5(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl5

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl5_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl5_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl5_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl5_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl5_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl5_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl5_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl5_getDOFsOffset(self)

# Register MovableJointImpl5 in _iDynTree:
_iDynTree.MovableJointImpl5_swigregister(MovableJointImpl5)

class MovableJointImpl6(IJoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_MovableJointImpl6

    def getNrOfPosCoords(self):
        return _iDynTree.MovableJointImpl6_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.MovableJointImpl6_getNrOfDOFs(self)

    def setIndex(self, _index):
        return _iDynTree.MovableJointImpl6_setIndex(self, _index)

    def getIndex(self):
        return _iDynTree.MovableJointImpl6_getIndex(self)

    def setPosCoordsOffset(self, _offset):
        return _iDynTree.MovableJointImpl6_setPosCoordsOffset(self, _offset)

    def getPosCoordsOffset(self):
        return _iDynTree.MovableJointImpl6_getPosCoordsOffset(self)

    def setDOFsOffset(self, _offset):
        return _iDynTree.MovableJointImpl6_setDOFsOffset(self, _offset)

    def getDOFsOffset(self):
        return _iDynTree.MovableJointImpl6_getDOFsOffset(self)

# Register MovableJointImpl6 in _iDynTree:
_iDynTree.MovableJointImpl6_swigregister(MovableJointImpl6)

class RevoluteJoint(MovableJointImpl1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.RevoluteJoint_swiginit(self, _iDynTree.new_RevoluteJoint(*args))
    __swig_destroy__ = _iDynTree.delete_RevoluteJoint

    def clone(self):
        return _iDynTree.RevoluteJoint_clone(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.RevoluteJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.RevoluteJoint_setRestTransform(self, link1_X_link2)

    def setAxis(self, *args):
        return _iDynTree.RevoluteJoint_setAxis(self, *args)

    def getFirstAttachedLink(self):
        return _iDynTree.RevoluteJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.RevoluteJoint_getSecondAttachedLink(self)

    def getAxis(self, *args):
        return _iDynTree.RevoluteJoint_getAxis(self, *args)

    def getRestTransform(self, child, parent):
        return _iDynTree.RevoluteJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.RevoluteJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.RevoluteJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, *args):
        return _iDynTree.RevoluteJoint_getMotionSubspaceVector(self, *args)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.RevoluteJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.RevoluteJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.RevoluteJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def hasPosLimits(self):
        return _iDynTree.RevoluteJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.RevoluteJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.RevoluteJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.RevoluteJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.RevoluteJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.RevoluteJoint_setPosLimits(self, _index, min, max)

# Register RevoluteJoint in _iDynTree:
_iDynTree.RevoluteJoint_swigregister(RevoluteJoint)

class PrismaticJoint(MovableJointImpl1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.PrismaticJoint_swiginit(self, _iDynTree.new_PrismaticJoint(*args))
    __swig_destroy__ = _iDynTree.delete_PrismaticJoint

    def clone(self):
        return _iDynTree.PrismaticJoint_clone(self)

    def setAttachedLinks(self, link1, link2):
        return _iDynTree.PrismaticJoint_setAttachedLinks(self, link1, link2)

    def setRestTransform(self, link1_X_link2):
        return _iDynTree.PrismaticJoint_setRestTransform(self, link1_X_link2)

    def setAxis(self, *args):
        return _iDynTree.PrismaticJoint_setAxis(self, *args)

    def getFirstAttachedLink(self):
        return _iDynTree.PrismaticJoint_getFirstAttachedLink(self)

    def getSecondAttachedLink(self):
        return _iDynTree.PrismaticJoint_getSecondAttachedLink(self)

    def getAxis(self, *args):
        return _iDynTree.PrismaticJoint_getAxis(self, *args)

    def getRestTransform(self, child, parent):
        return _iDynTree.PrismaticJoint_getRestTransform(self, child, parent)

    def getTransform(self, jntPos, child, parent):
        return _iDynTree.PrismaticJoint_getTransform(self, jntPos, child, parent)

    def getTransformDerivative(self, jntPos, child, parent, posCoord_i):
        return _iDynTree.PrismaticJoint_getTransformDerivative(self, jntPos, child, parent, posCoord_i)

    def getMotionSubspaceVector(self, *args):
        return _iDynTree.PrismaticJoint_getMotionSubspaceVector(self, *args)

    def computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildPosVelAcc(self, jntPos, jntVel, jntAcc, linkPositions, linkVels, linkAccs, child, parent)

    def computeChildVel(self, jntPos, jntVel, linkVels, child, parent):
        return _iDynTree.PrismaticJoint_computeChildVel(self, jntPos, jntVel, linkVels, child, parent)

    def computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildVelAcc(self, jntPos, jntVel, jntAcc, linkVels, linkAccs, child, parent)

    def computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildAcc(self, jntPos, jntVel, linkVels, jntAcc, linkAccs, child, parent)

    def computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent):
        return _iDynTree.PrismaticJoint_computeChildBiasAcc(self, jntPos, jntVel, linkVels, linkBiasAccs, child, parent)

    def computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques):
        return _iDynTree.PrismaticJoint_computeJointTorque(self, jntPos, internalWrench, linkThatAppliesWrench, linkOnWhichWrenchIsApplied, jntTorques)

    def hasPosLimits(self):
        return _iDynTree.PrismaticJoint_hasPosLimits(self)

    def enablePosLimits(self, enable):
        return _iDynTree.PrismaticJoint_enablePosLimits(self, enable)

    def getPosLimits(self, _index, min, max):
        return _iDynTree.PrismaticJoint_getPosLimits(self, _index, min, max)

    def getMinPosLimit(self, _index):
        return _iDynTree.PrismaticJoint_getMinPosLimit(self, _index)

    def getMaxPosLimit(self, _index):
        return _iDynTree.PrismaticJoint_getMaxPosLimit(self, _index)

    def setPosLimits(self, _index, min, max):
        return _iDynTree.PrismaticJoint_setPosLimits(self, _index, min, max)

# Register PrismaticJoint in _iDynTree:
_iDynTree.PrismaticJoint_swigregister(PrismaticJoint)

class Traversal(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.Traversal_swiginit(self, _iDynTree.new_Traversal())
    __swig_destroy__ = _iDynTree.delete_Traversal

    def getNrOfVisitedLinks(self):
        return _iDynTree.Traversal_getNrOfVisitedLinks(self)

    def getLink(self, traversalIndex):
        return _iDynTree.Traversal_getLink(self, traversalIndex)

    def getBaseLink(self):
        return _iDynTree.Traversal_getBaseLink(self)

    def getParentLink(self, traversalIndex):
        return _iDynTree.Traversal_getParentLink(self, traversalIndex)

    def getParentJoint(self, traversalIndex):
        return _iDynTree.Traversal_getParentJoint(self, traversalIndex)

    def getParentLinkFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getParentLinkFromLinkIndex(self, linkIndex)

    def getParentJointFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getParentJointFromLinkIndex(self, linkIndex)

    def getTraversalIndexFromLinkIndex(self, linkIndex):
        return _iDynTree.Traversal_getTraversalIndexFromLinkIndex(self, linkIndex)

    def reset(self, *args):
        return _iDynTree.Traversal_reset(self, *args)

    def addTraversalBase(self, link):
        return _iDynTree.Traversal_addTraversalBase(self, link)

    def addTraversalElement(self, link, jointToParent, parentLink):
        return _iDynTree.Traversal_addTraversalElement(self, link, jointToParent, parentLink)

    def isParentOf(self, parentCandidate, childCandidate):
        return _iDynTree.Traversal_isParentOf(self, parentCandidate, childCandidate)

    def getChildLinkIndexFromJointIndex(self, model, jntIdx):
        return _iDynTree.Traversal_getChildLinkIndexFromJointIndex(self, model, jntIdx)

    def getParentLinkIndexFromJointIndex(self, model, jntIdx):
        return _iDynTree.Traversal_getParentLinkIndexFromJointIndex(self, model, jntIdx)

    def toString(self, model):
        return _iDynTree.Traversal_toString(self, model)

# Register Traversal in _iDynTree:
_iDynTree.Traversal_swigregister(Traversal)

class Material(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Material_swiginit(self, _iDynTree.new_Material(*args))

    def name(self):
        return _iDynTree.Material_name(self)

    def hasColor(self):
        return _iDynTree.Material_hasColor(self)

    def color(self):
        return _iDynTree.Material_color(self)

    def setColor(self, color):
        return _iDynTree.Material_setColor(self, color)

    def hasTexture(self):
        return _iDynTree.Material_hasTexture(self)

    def texture(self):
        return _iDynTree.Material_texture(self)

    def setTexture(self, texture):
        return _iDynTree.Material_setTexture(self, texture)
    __swig_destroy__ = _iDynTree.delete_Material

# Register Material in _iDynTree:
_iDynTree.Material_swigregister(Material)

class SolidShape(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_SolidShape

    def clone(self):
        return _iDynTree.SolidShape_clone(self)

    def getName(self):
        return _iDynTree.SolidShape_getName(self)

    def setName(self, name):
        return _iDynTree.SolidShape_setName(self, name)

    def isNameValid(self):
        return _iDynTree.SolidShape_isNameValid(self)

    def getLink_H_geometry(self):
        return _iDynTree.SolidShape_getLink_H_geometry(self)

    def setLink_H_geometry(self, newTransform):
        return _iDynTree.SolidShape_setLink_H_geometry(self, newTransform)

    def isMaterialSet(self):
        return _iDynTree.SolidShape_isMaterialSet(self)

    def getMaterial(self):
        return _iDynTree.SolidShape_getMaterial(self)

    def setMaterial(self, material):
        return _iDynTree.SolidShape_setMaterial(self, material)

    def isSphere(self):
        return _iDynTree.SolidShape_isSphere(self)

    def isBox(self):
        return _iDynTree.SolidShape_isBox(self)

    def isCylinder(self):
        return _iDynTree.SolidShape_isCylinder(self)

    def isExternalMesh(self):
        return _iDynTree.SolidShape_isExternalMesh(self)

    def asSphere(self, *args):
        return _iDynTree.SolidShape_asSphere(self, *args)

    def asBox(self, *args):
        return _iDynTree.SolidShape_asBox(self, *args)

    def asCylinder(self, *args):
        return _iDynTree.SolidShape_asCylinder(self, *args)

    def asExternalMesh(self, *args):
        return _iDynTree.SolidShape_asExternalMesh(self, *args)

# Register SolidShape in _iDynTree:
_iDynTree.SolidShape_swigregister(SolidShape)

class Sphere(SolidShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Sphere

    def clone(self):
        return _iDynTree.Sphere_clone(self)

    def getRadius(self):
        return _iDynTree.Sphere_getRadius(self)

    def setRadius(self, radius):
        return _iDynTree.Sphere_setRadius(self, radius)

    def __init__(self):
        _iDynTree.Sphere_swiginit(self, _iDynTree.new_Sphere())

# Register Sphere in _iDynTree:
_iDynTree.Sphere_swigregister(Sphere)

class Box(SolidShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Box

    def clone(self):
        return _iDynTree.Box_clone(self)

    def getX(self):
        return _iDynTree.Box_getX(self)

    def setX(self, x):
        return _iDynTree.Box_setX(self, x)

    def getY(self):
        return _iDynTree.Box_getY(self)

    def setY(self, y):
        return _iDynTree.Box_setY(self, y)

    def getZ(self):
        return _iDynTree.Box_getZ(self)

    def setZ(self, z):
        return _iDynTree.Box_setZ(self, z)

    def __init__(self):
        _iDynTree.Box_swiginit(self, _iDynTree.new_Box())

# Register Box in _iDynTree:
_iDynTree.Box_swigregister(Box)

class Cylinder(SolidShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Cylinder

    def clone(self):
        return _iDynTree.Cylinder_clone(self)

    def getLength(self):
        return _iDynTree.Cylinder_getLength(self)

    def setLength(self, length):
        return _iDynTree.Cylinder_setLength(self, length)

    def getRadius(self):
        return _iDynTree.Cylinder_getRadius(self)

    def setRadius(self, radius):
        return _iDynTree.Cylinder_setRadius(self, radius)

    def __init__(self):
        _iDynTree.Cylinder_swiginit(self, _iDynTree.new_Cylinder())

# Register Cylinder in _iDynTree:
_iDynTree.Cylinder_swigregister(Cylinder)

class ExternalMesh(SolidShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ExternalMesh

    def clone(self):
        return _iDynTree.ExternalMesh_clone(self)

    def getFilename(self):
        return _iDynTree.ExternalMesh_getFilename(self)

    def getFileLocationOnLocalFileSystem(self):
        return _iDynTree.ExternalMesh_getFileLocationOnLocalFileSystem(self)

    def setFilename(self, filename):
        return _iDynTree.ExternalMesh_setFilename(self, filename)

    def getScale(self):
        return _iDynTree.ExternalMesh_getScale(self)

    def setScale(self, scale):
        return _iDynTree.ExternalMesh_setScale(self, scale)

    def __init__(self):
        _iDynTree.ExternalMesh_swiginit(self, _iDynTree.new_ExternalMesh())

# Register ExternalMesh in _iDynTree:
_iDynTree.ExternalMesh_swigregister(ExternalMesh)

class ModelSolidShapes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ModelSolidShapes

    def __init__(self, *args):
        _iDynTree.ModelSolidShapes_swiginit(self, _iDynTree.new_ModelSolidShapes(*args))

    def clear(self):
        return _iDynTree.ModelSolidShapes_clear(self)

    def resize(self, *args):
        return _iDynTree.ModelSolidShapes_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.ModelSolidShapes_isConsistent(self, model)

    def getLinkSolidShapes(self, *args):
        return _iDynTree.ModelSolidShapes_getLinkSolidShapes(self, *args)

# Register ModelSolidShapes in _iDynTree:
_iDynTree.ModelSolidShapes_swigregister(ModelSolidShapes)

class Neighbor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    neighborLink = property(_iDynTree.Neighbor_neighborLink_get, _iDynTree.Neighbor_neighborLink_set)
    neighborJoint = property(_iDynTree.Neighbor_neighborJoint_get, _iDynTree.Neighbor_neighborJoint_set)

    def __init__(self):
        _iDynTree.Neighbor_swiginit(self, _iDynTree.new_Neighbor())
    __swig_destroy__ = _iDynTree.delete_Neighbor

# Register Neighbor in _iDynTree:
_iDynTree.Neighbor_swigregister(Neighbor)

class Model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.Model_swiginit(self, _iDynTree.new_Model(*args))

    def copy(self):
        return _iDynTree.Model_copy(self)
    __swig_destroy__ = _iDynTree.delete_Model

    def getNrOfLinks(self):
        return _iDynTree.Model_getNrOfLinks(self)

    def getLinkName(self, linkIndex):
        return _iDynTree.Model_getLinkName(self, linkIndex)

    def getLinkIndex(self, linkName):
        return _iDynTree.Model_getLinkIndex(self, linkName)

    def isValidLinkIndex(self, index):
        return _iDynTree.Model_isValidLinkIndex(self, index)

    def getLink(self, *args):
        return _iDynTree.Model_getLink(self, *args)

    def addLink(self, name, link):
        return _iDynTree.Model_addLink(self, name, link)

    def getNrOfJoints(self):
        return _iDynTree.Model_getNrOfJoints(self)

    def getJointName(self, index):
        return _iDynTree.Model_getJointName(self, index)

    def getTotalMass(self):
        return _iDynTree.Model_getTotalMass(self)

    def getJointIndex(self, jointName):
        return _iDynTree.Model_getJointIndex(self, jointName)

    def getJoint(self, *args):
        return _iDynTree.Model_getJoint(self, *args)

    def isValidJointIndex(self, index):
        return _iDynTree.Model_isValidJointIndex(self, index)

    def isLinkNameUsed(self, linkName):
        return _iDynTree.Model_isLinkNameUsed(self, linkName)

    def isJointNameUsed(self, jointName):
        return _iDynTree.Model_isJointNameUsed(self, jointName)

    def isFrameNameUsed(self, frameName):
        return _iDynTree.Model_isFrameNameUsed(self, frameName)

    def addJoint(self, *args):
        return _iDynTree.Model_addJoint(self, *args)

    def addJointAndLink(self, existingLink, jointName, joint, newLinkName, newLink):
        return _iDynTree.Model_addJointAndLink(self, existingLink, jointName, joint, newLinkName, newLink)

    def insertLinkToExistingJointAndAddJointForDisplacedLink(self, existingJoint, unmovableLink, _unmovableLink_X_newLink, jointName, joint, newLinkName, newLink):
        return _iDynTree.Model_insertLinkToExistingJointAndAddJointForDisplacedLink(self, existingJoint, unmovableLink, _unmovableLink_X_newLink, jointName, joint, newLinkName, newLink)

    def getNrOfPosCoords(self):
        return _iDynTree.Model_getNrOfPosCoords(self)

    def getNrOfDOFs(self):
        return _iDynTree.Model_getNrOfDOFs(self)

    def getNrOfFrames(self):
        return _iDynTree.Model_getNrOfFrames(self)

    def addAdditionalFrameToLink(self, linkName, frameName, link_H_frame):
        return _iDynTree.Model_addAdditionalFrameToLink(self, linkName, frameName, link_H_frame)

    def getFrameName(self, frameIndex):
        return _iDynTree.Model_getFrameName(self, frameIndex)

    def getFrameIndex(self, frameName):
        return _iDynTree.Model_getFrameIndex(self, frameName)

    def isValidFrameIndex(self, index):
        return _iDynTree.Model_isValidFrameIndex(self, index)

    def getFrameTransform(self, frameIndex):
        return _iDynTree.Model_getFrameTransform(self, frameIndex)

    def getFrameLink(self, frameIndex):
        return _iDynTree.Model_getFrameLink(self, frameIndex)

    def getLinkAdditionalFrames(self, lnkIndex, frameIndeces):
        return _iDynTree.Model_getLinkAdditionalFrames(self, lnkIndex, frameIndeces)

    def getNrOfNeighbors(self, link):
        return _iDynTree.Model_getNrOfNeighbors(self, link)

    def getNeighbor(self, link, neighborIndex):
        return _iDynTree.Model_getNeighbor(self, link, neighborIndex)

    def setDefaultBaseLink(self, linkIndex):
        return _iDynTree.Model_setDefaultBaseLink(self, linkIndex)

    def getDefaultBaseLink(self):
        return _iDynTree.Model_getDefaultBaseLink(self)

    def computeFullTreeTraversal(self, *args):
        return _iDynTree.Model_computeFullTreeTraversal(self, *args)

    def getInertialParameters(self, modelInertialParams):
        return _iDynTree.Model_getInertialParameters(self, modelInertialParams)

    def updateInertialParameters(self, modelInertialParams):
        return _iDynTree.Model_updateInertialParameters(self, modelInertialParams)

    def visualSolidShapes(self, *args):
        return _iDynTree.Model_visualSolidShapes(self, *args)

    def collisionSolidShapes(self, *args):
        return _iDynTree.Model_collisionSolidShapes(self, *args)

    def toString(self):
        return _iDynTree.Model_toString(self)

# Register Model in _iDynTree:
_iDynTree.Model_swigregister(Model)

class JointPosDoubleArray(VectorDynSize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.JointPosDoubleArray_swiginit(self, _iDynTree.new_JointPosDoubleArray(*args))

    def resize(self, *args):
        return _iDynTree.JointPosDoubleArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.JointPosDoubleArray_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_JointPosDoubleArray

# Register JointPosDoubleArray in _iDynTree:
_iDynTree.JointPosDoubleArray_swigregister(JointPosDoubleArray)

class JointDOFsDoubleArray(VectorDynSize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.JointDOFsDoubleArray_swiginit(self, _iDynTree.new_JointDOFsDoubleArray(*args))

    def resize(self, *args):
        return _iDynTree.JointDOFsDoubleArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.JointDOFsDoubleArray_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_JointDOFsDoubleArray

# Register JointDOFsDoubleArray in _iDynTree:
_iDynTree.JointDOFsDoubleArray_swigregister(JointDOFsDoubleArray)

class DOFSpatialForceArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.DOFSpatialForceArray_swiginit(self, _iDynTree.new_DOFSpatialForceArray(*args))

    def resize(self, *args):
        return _iDynTree.DOFSpatialForceArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.DOFSpatialForceArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.DOFSpatialForceArray___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_DOFSpatialForceArray

# Register DOFSpatialForceArray in _iDynTree:
_iDynTree.DOFSpatialForceArray_swigregister(DOFSpatialForceArray)

class DOFSpatialMotionArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.DOFSpatialMotionArray_swiginit(self, _iDynTree.new_DOFSpatialMotionArray(*args))

    def resize(self, *args):
        return _iDynTree.DOFSpatialMotionArray_resize(self, *args)

    def isConsistent(self, model):
        return _iDynTree.DOFSpatialMotionArray_isConsistent(self, model)

    def __call__(self, *args):
        return _iDynTree.DOFSpatialMotionArray___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_DOFSpatialMotionArray

# Register DOFSpatialMotionArray in _iDynTree:
_iDynTree.DOFSpatialMotionArray_swigregister(DOFSpatialMotionArray)

INERTIAL_FIXED_REPRESENTATION = _iDynTree.INERTIAL_FIXED_REPRESENTATION
BODY_FIXED_REPRESENTATION = _iDynTree.BODY_FIXED_REPRESENTATION
MIXED_REPRESENTATION = _iDynTree.MIXED_REPRESENTATION
class FrameFreeFloatingJacobian(MatrixDynSize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FrameFreeFloatingJacobian_swiginit(self, _iDynTree.new_FrameFreeFloatingJacobian(*args))

    def resize(self, model):
        return _iDynTree.FrameFreeFloatingJacobian_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.FrameFreeFloatingJacobian_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_FrameFreeFloatingJacobian

# Register FrameFreeFloatingJacobian in _iDynTree:
_iDynTree.FrameFreeFloatingJacobian_swigregister(FrameFreeFloatingJacobian)

class MomentumFreeFloatingJacobian(MatrixDynSize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.MomentumFreeFloatingJacobian_swiginit(self, _iDynTree.new_MomentumFreeFloatingJacobian(*args))

    def resize(self, model):
        return _iDynTree.MomentumFreeFloatingJacobian_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.MomentumFreeFloatingJacobian_isConsistent(self, model)
    __swig_destroy__ = _iDynTree.delete_MomentumFreeFloatingJacobian

# Register MomentumFreeFloatingJacobian in _iDynTree:
_iDynTree.MomentumFreeFloatingJacobian_swigregister(MomentumFreeFloatingJacobian)

class FreeFloatingMassMatrix(MatrixDynSize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FreeFloatingMassMatrix_swiginit(self, _iDynTree.new_FreeFloatingMassMatrix(*args))

    def resize(self, model):
        return _iDynTree.FreeFloatingMassMatrix_resize(self, model)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingMassMatrix

# Register FreeFloatingMassMatrix in _iDynTree:
_iDynTree.FreeFloatingMassMatrix_swigregister(FreeFloatingMassMatrix)

class FreeFloatingPos(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FreeFloatingPos_swiginit(self, _iDynTree.new_FreeFloatingPos(*args))

    def resize(self, model):
        return _iDynTree.FreeFloatingPos_resize(self, model)

    def getNrOfPosCoords(self):
        return _iDynTree.FreeFloatingPos_getNrOfPosCoords(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingPos
    worldBasePos = property(_iDynTree.FreeFloatingPos_worldBasePos_get, _iDynTree.FreeFloatingPos_worldBasePos_set)
    jointPos = property(_iDynTree.FreeFloatingPos_jointPos_get, _iDynTree.FreeFloatingPos_jointPos_set)

# Register FreeFloatingPos in _iDynTree:
_iDynTree.FreeFloatingPos_swigregister(FreeFloatingPos)

class FreeFloatingGeneralizedTorques(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FreeFloatingGeneralizedTorques_swiginit(self, _iDynTree.new_FreeFloatingGeneralizedTorques(*args))

    def resize(self, model):
        return _iDynTree.FreeFloatingGeneralizedTorques_resize(self, model)

    def baseWrench(self, *args):
        return _iDynTree.FreeFloatingGeneralizedTorques_baseWrench(self, *args)

    def jointTorques(self, *args):
        return _iDynTree.FreeFloatingGeneralizedTorques_jointTorques(self, *args)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingGeneralizedTorques_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingGeneralizedTorques

# Register FreeFloatingGeneralizedTorques in _iDynTree:
_iDynTree.FreeFloatingGeneralizedTorques_swigregister(FreeFloatingGeneralizedTorques)

class FreeFloatingVel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FreeFloatingVel_swiginit(self, _iDynTree.new_FreeFloatingVel(*args))

    def resize(self, model):
        return _iDynTree.FreeFloatingVel_resize(self, model)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingVel_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingVel
    baseVel = property(_iDynTree.FreeFloatingVel_baseVel_get, _iDynTree.FreeFloatingVel_baseVel_set)
    jointVel = property(_iDynTree.FreeFloatingVel_jointVel_get, _iDynTree.FreeFloatingVel_jointVel_set)

# Register FreeFloatingVel in _iDynTree:
_iDynTree.FreeFloatingVel_swigregister(FreeFloatingVel)

class FreeFloatingAcc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.FreeFloatingAcc_swiginit(self, _iDynTree.new_FreeFloatingAcc(*args))

    def resize(self, model):
        return _iDynTree.FreeFloatingAcc_resize(self, model)

    def getNrOfDOFs(self):
        return _iDynTree.FreeFloatingAcc_getNrOfDOFs(self)
    __swig_destroy__ = _iDynTree.delete_FreeFloatingAcc
    baseAcc = property(_iDynTree.FreeFloatingAcc_baseAcc_get, _iDynTree.FreeFloatingAcc_baseAcc_set)
    jointAcc = property(_iDynTree.FreeFloatingAcc_jointAcc_get, _iDynTree.FreeFloatingAcc_jointAcc_set)

# Register FreeFloatingAcc in _iDynTree:
_iDynTree.FreeFloatingAcc_swigregister(FreeFloatingAcc)

class ContactWrench(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def contactId(self):
        return _iDynTree.ContactWrench_contactId(self)

    def contactPoint(self, *args):
        return _iDynTree.ContactWrench_contactPoint(self, *args)

    def contactWrench(self, *args):
        return _iDynTree.ContactWrench_contactWrench(self, *args)

    def __init__(self):
        _iDynTree.ContactWrench_swiginit(self, _iDynTree.new_ContactWrench())
    __swig_destroy__ = _iDynTree.delete_ContactWrench

# Register ContactWrench in _iDynTree:
_iDynTree.ContactWrench_swigregister(ContactWrench)

class LinkContactWrenches(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkContactWrenches_swiginit(self, _iDynTree.new_LinkContactWrenches(*args))

    def resize(self, *args):
        return _iDynTree.LinkContactWrenches_resize(self, *args)

    def getNrOfContactsForLink(self, linkIndex):
        return _iDynTree.LinkContactWrenches_getNrOfContactsForLink(self, linkIndex)

    def setNrOfContactsForLink(self, linkIndex, nrOfContacts):
        return _iDynTree.LinkContactWrenches_setNrOfContactsForLink(self, linkIndex, nrOfContacts)

    def getNrOfLinks(self):
        return _iDynTree.LinkContactWrenches_getNrOfLinks(self)

    def contactWrench(self, *args):
        return _iDynTree.LinkContactWrenches_contactWrench(self, *args)

    def computeNetWrenches(self, netWrenches):
        return _iDynTree.LinkContactWrenches_computeNetWrenches(self, netWrenches)

    def toString(self, model):
        return _iDynTree.LinkContactWrenches_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkContactWrenches

# Register LinkContactWrenches in _iDynTree:
_iDynTree.LinkContactWrenches_swigregister(LinkContactWrenches)


def getRandomLink():
    return _iDynTree.getRandomLink()

def addRandomLinkToModel(model, parentLink, newLinkName, noFixed=False):
    return _iDynTree.addRandomLinkToModel(model, parentLink, newLinkName, noFixed)

def addRandomAdditionalFrameToModel(model, parentLink, newFrameName):
    return _iDynTree.addRandomAdditionalFrameToModel(model, parentLink, newFrameName)

def getRandomLinkIndexOfModel(model):
    return _iDynTree.getRandomLinkIndexOfModel(model)

def getRandomLinkOfModel(model):
    return _iDynTree.getRandomLinkOfModel(model)

def int2string(i):
    return _iDynTree.int2string(i)

def getRandomModel(nrOfJoints, nrOfAdditionalFrames=10):
    return _iDynTree.getRandomModel(nrOfJoints, nrOfAdditionalFrames)

def getRandomChain(nrOfJoints, nrOfAdditionalFrames=10, noFixed=False):
    return _iDynTree.getRandomChain(nrOfJoints, nrOfAdditionalFrames, noFixed)

def getRandomJointPositions(vec, model):
    return _iDynTree.getRandomJointPositions(vec, model)

def getRandomInverseDynamicsInputs(pos, vel, acc, extWrenches):
    return _iDynTree.getRandomInverseDynamicsInputs(pos, vel, acc, extWrenches)
class SolidShapesVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.SolidShapesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.SolidShapesVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.SolidShapesVector___bool__(self)

    def __len__(self):
        return _iDynTree.SolidShapesVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.SolidShapesVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.SolidShapesVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.SolidShapesVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.SolidShapesVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.SolidShapesVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.SolidShapesVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.SolidShapesVector_pop(self)

    def append(self, x):
        return _iDynTree.SolidShapesVector_append(self, x)

    def empty(self):
        return _iDynTree.SolidShapesVector_empty(self)

    def size(self):
        return _iDynTree.SolidShapesVector_size(self)

    def swap(self, v):
        return _iDynTree.SolidShapesVector_swap(self, v)

    def begin(self):
        return _iDynTree.SolidShapesVector_begin(self)

    def end(self):
        return _iDynTree.SolidShapesVector_end(self)

    def rbegin(self):
        return _iDynTree.SolidShapesVector_rbegin(self)

    def rend(self):
        return _iDynTree.SolidShapesVector_rend(self)

    def clear(self):
        return _iDynTree.SolidShapesVector_clear(self)

    def get_allocator(self):
        return _iDynTree.SolidShapesVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.SolidShapesVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.SolidShapesVector_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.SolidShapesVector_swiginit(self, _iDynTree.new_SolidShapesVector(*args))

    def push_back(self, x):
        return _iDynTree.SolidShapesVector_push_back(self, x)

    def front(self):
        return _iDynTree.SolidShapesVector_front(self)

    def back(self):
        return _iDynTree.SolidShapesVector_back(self)

    def assign(self, n, x):
        return _iDynTree.SolidShapesVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.SolidShapesVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.SolidShapesVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.SolidShapesVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.SolidShapesVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_SolidShapesVector

# Register SolidShapesVector in _iDynTree:
_iDynTree.SolidShapesVector_swigregister(SolidShapesVector)

class LinksSolidShapesVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.LinksSolidShapesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.LinksSolidShapesVector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.LinksSolidShapesVector___bool__(self)

    def __len__(self):
        return _iDynTree.LinksSolidShapesVector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.LinksSolidShapesVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.LinksSolidShapesVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.LinksSolidShapesVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.LinksSolidShapesVector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.LinksSolidShapesVector_pop(self)

    def append(self, x):
        return _iDynTree.LinksSolidShapesVector_append(self, x)

    def empty(self):
        return _iDynTree.LinksSolidShapesVector_empty(self)

    def size(self):
        return _iDynTree.LinksSolidShapesVector_size(self)

    def swap(self, v):
        return _iDynTree.LinksSolidShapesVector_swap(self, v)

    def begin(self):
        return _iDynTree.LinksSolidShapesVector_begin(self)

    def end(self):
        return _iDynTree.LinksSolidShapesVector_end(self)

    def rbegin(self):
        return _iDynTree.LinksSolidShapesVector_rbegin(self)

    def rend(self):
        return _iDynTree.LinksSolidShapesVector_rend(self)

    def clear(self):
        return _iDynTree.LinksSolidShapesVector_clear(self)

    def get_allocator(self):
        return _iDynTree.LinksSolidShapesVector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.LinksSolidShapesVector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.LinksSolidShapesVector_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.LinksSolidShapesVector_swiginit(self, _iDynTree.new_LinksSolidShapesVector(*args))

    def push_back(self, x):
        return _iDynTree.LinksSolidShapesVector_push_back(self, x)

    def front(self):
        return _iDynTree.LinksSolidShapesVector_front(self)

    def back(self):
        return _iDynTree.LinksSolidShapesVector_back(self)

    def assign(self, n, x):
        return _iDynTree.LinksSolidShapesVector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.LinksSolidShapesVector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.LinksSolidShapesVector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.LinksSolidShapesVector_reserve(self, n)

    def capacity(self):
        return _iDynTree.LinksSolidShapesVector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_LinksSolidShapesVector

# Register LinksSolidShapesVector in _iDynTree:
_iDynTree.LinksSolidShapesVector_swigregister(LinksSolidShapesVector)


def ForwardPositionKinematics(*args):
    return _iDynTree.ForwardPositionKinematics(*args)

def ForwardVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc):
    return _iDynTree.ForwardVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc)

def ForwardPosVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkPos, linkVel, linkAcc):
    return _iDynTree.ForwardPosVelAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkPos, linkVel, linkAcc)

def ForwardPosVelKinematics(model, traversal, robotPos, robotVel, linkPos, linkVel):
    return _iDynTree.ForwardPosVelKinematics(model, traversal, robotPos, robotVel, linkPos, linkVel)

def ForwardAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc):
    return _iDynTree.ForwardAccKinematics(model, traversal, robotPos, robotVel, robotAcc, linkVel, linkAcc)

def ForwardBiasAccKinematics(*args):
    return _iDynTree.ForwardBiasAccKinematics(*args)

def ComputeLinearAndAngularMomentum(model, linkPositions, linkVels, totalMomentum):
    return _iDynTree.ComputeLinearAndAngularMomentum(model, linkPositions, linkVels, totalMomentum)

def ComputeLinearAndAngularMomentumDerivativeBias(model, linkPositions, linkVel, linkBiasAcc, totalMomentumBias):
    return _iDynTree.ComputeLinearAndAngularMomentumDerivativeBias(model, linkPositions, linkVel, linkBiasAcc, totalMomentumBias)

def RNEADynamicPhase(model, traversal, jointPos, linksVel, linksProperAcc, linkExtForces, linkIntWrenches, baseForceAndJointTorques):
    return _iDynTree.RNEADynamicPhase(model, traversal, jointPos, linksVel, linksProperAcc, linkExtForces, linkIntWrenches, baseForceAndJointTorques)

def CompositeRigidBodyAlgorithm(model, traversal, jointPos, linkCRBs, massMatrix):
    return _iDynTree.CompositeRigidBodyAlgorithm(model, traversal, jointPos, linkCRBs, massMatrix)
class ArticulatedBodyAlgorithmInternalBuffers(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_swiginit(self, _iDynTree.new_ArticulatedBodyAlgorithmInternalBuffers(*args))

    def resize(self, model):
        return _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_resize(self, model)

    def isConsistent(self, model):
        return _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_isConsistent(self, model)
    S = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_S_set)
    U = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_U_set)
    D = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_D_set)
    u = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_u_set)
    linksVel = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksVel_set)
    linksBiasAcceleration = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set)
    linksAccelerations = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set)
    linkABIs = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set)
    linksBiasWrench = property(_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get, _iDynTree.ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set)
    __swig_destroy__ = _iDynTree.delete_ArticulatedBodyAlgorithmInternalBuffers

# Register ArticulatedBodyAlgorithmInternalBuffers in _iDynTree:
_iDynTree.ArticulatedBodyAlgorithmInternalBuffers_swigregister(ArticulatedBodyAlgorithmInternalBuffers)


def ArticulatedBodyAlgorithm(model, traversal, robotPos, robotVel, linkExtWrenches, jointTorques, buffers, robotAcc):
    return _iDynTree.ArticulatedBodyAlgorithm(model, traversal, robotPos, robotVel, linkExtWrenches, jointTorques, buffers, robotAcc)

def InverseDynamicsInertialParametersRegressor(model, traversal, referenceFrame_H_link, linksVel, linksAcc, baseForceAndJointTorquesRegressor):
    return _iDynTree.InverseDynamicsInertialParametersRegressor(model, traversal, referenceFrame_H_link, linksVel, linksAcc, baseForceAndJointTorquesRegressor)
SIX_AXIS_FORCE_TORQUE = _iDynTree.SIX_AXIS_FORCE_TORQUE
ACCELEROMETER = _iDynTree.ACCELEROMETER
GYROSCOPE = _iDynTree.GYROSCOPE
THREE_AXIS_ANGULAR_ACCELEROMETER = _iDynTree.THREE_AXIS_ANGULAR_ACCELEROMETER
THREE_AXIS_FORCE_TORQUE_CONTACT = _iDynTree.THREE_AXIS_FORCE_TORQUE_CONTACT

def isLinkSensor(type):
    return _iDynTree.isLinkSensor(type)

def isJointSensor(type):
    return _iDynTree.isJointSensor(type)

def getSensorTypeSize(type):
    return _iDynTree.getSensorTypeSize(type)
class Sensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_Sensor

    def getName(self):
        return _iDynTree.Sensor_getName(self)

    def getSensorType(self):
        return _iDynTree.Sensor_getSensorType(self)

    def isValid(self):
        return _iDynTree.Sensor_isValid(self)

    def setName(self, arg2):
        return _iDynTree.Sensor_setName(self, arg2)

    def clone(self):
        return _iDynTree.Sensor_clone(self)

    def isConsistent(self, model):
        return _iDynTree.Sensor_isConsistent(self, model)

    def updateIndices(self, model):
        return _iDynTree.Sensor_updateIndices(self, model)

# Register Sensor in _iDynTree:
_iDynTree.Sensor_swigregister(Sensor)
NR_OF_SENSOR_TYPES = cvar.NR_OF_SENSOR_TYPES

class JointSensor(Sensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_JointSensor

    def getParentJoint(self):
        return _iDynTree.JointSensor_getParentJoint(self)

    def getParentJointIndex(self):
        return _iDynTree.JointSensor_getParentJointIndex(self)

    def setParentJoint(self, parentJointName):
        return _iDynTree.JointSensor_setParentJoint(self, parentJointName)

    def setParentJointIndex(self, arg2):
        return _iDynTree.JointSensor_setParentJointIndex(self, arg2)

    def isConsistent(self, model):
        return _iDynTree.JointSensor_isConsistent(self, model)

# Register JointSensor in _iDynTree:
_iDynTree.JointSensor_swigregister(JointSensor)

class LinkSensor(Sensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_LinkSensor

    def getParentLink(self):
        return _iDynTree.LinkSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.LinkSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.LinkSensor_getLinkSensorTransform(self)

    def setParentLink(self, parentLinkName):
        return _iDynTree.LinkSensor_setParentLink(self, parentLinkName)

    def setParentLinkIndex(self, arg2):
        return _iDynTree.LinkSensor_setParentLinkIndex(self, arg2)

    def setLinkSensorTransform(self, arg2):
        return _iDynTree.LinkSensor_setLinkSensorTransform(self, arg2)

    def isConsistent(self, model):
        return _iDynTree.LinkSensor_isConsistent(self, model)

# Register LinkSensor in _iDynTree:
_iDynTree.LinkSensor_swigregister(LinkSensor)

class SensorsList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SensorsList_swiginit(self, _iDynTree.new_SensorsList(*args))
    __swig_destroy__ = _iDynTree.delete_SensorsList

    def addSensor(self, sensor):
        return _iDynTree.SensorsList_addSensor(self, sensor)

    def setSerialization(self, sensor_type, serializaton):
        return _iDynTree.SensorsList_setSerialization(self, sensor_type, serializaton)

    def getSerialization(self, sensor_type, serializaton):
        return _iDynTree.SensorsList_getSerialization(self, sensor_type, serializaton)

    def getNrOfSensors(self, sensor_type):
        return _iDynTree.SensorsList_getNrOfSensors(self, sensor_type)

    def getSensorIndex(self, *args):
        return _iDynTree.SensorsList_getSensorIndex(self, *args)

    def getSizeOfAllSensorsMeasurements(self):
        return _iDynTree.SensorsList_getSizeOfAllSensorsMeasurements(self)

    def getSensor(self, sensor_type, sensor_index):
        return _iDynTree.SensorsList_getSensor(self, sensor_type, sensor_index)

    def isConsistent(self, model):
        return _iDynTree.SensorsList_isConsistent(self, model)

    def removeSensor(self, *args):
        return _iDynTree.SensorsList_removeSensor(self, *args)

    def removeAllSensorsOfType(self, sensor_type):
        return _iDynTree.SensorsList_removeAllSensorsOfType(self, sensor_type)

    def getSixAxisForceTorqueSensor(self, sensor_index):
        return _iDynTree.SensorsList_getSixAxisForceTorqueSensor(self, sensor_index)

    def getAccelerometerSensor(self, sensor_index):
        return _iDynTree.SensorsList_getAccelerometerSensor(self, sensor_index)

    def getGyroscopeSensor(self, sensor_index):
        return _iDynTree.SensorsList_getGyroscopeSensor(self, sensor_index)

    def getThreeAxisAngularAccelerometerSensor(self, sensor_index):
        return _iDynTree.SensorsList_getThreeAxisAngularAccelerometerSensor(self, sensor_index)

    def getThreeAxisForceTorqueContactSensor(self, sensor_index):
        return _iDynTree.SensorsList_getThreeAxisForceTorqueContactSensor(self, sensor_index)

# Register SensorsList in _iDynTree:
_iDynTree.SensorsList_swigregister(SensorsList)

class SensorsMeasurements(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SensorsMeasurements_swiginit(self, _iDynTree.new_SensorsMeasurements(*args))
    __swig_destroy__ = _iDynTree.delete_SensorsMeasurements

    def setNrOfSensors(self, sensor_type, nrOfSensors):
        return _iDynTree.SensorsMeasurements_setNrOfSensors(self, sensor_type, nrOfSensors)

    def getNrOfSensors(self, sensor_type):
        return _iDynTree.SensorsMeasurements_getNrOfSensors(self, sensor_type)

    def resize(self, sensorsList):
        return _iDynTree.SensorsMeasurements_resize(self, sensorsList)

    def toVector(self, measurementVector):
        return _iDynTree.SensorsMeasurements_toVector(self, measurementVector)

    def setMeasurement(self, *args):
        return _iDynTree.SensorsMeasurements_setMeasurement(self, *args)

    def getMeasurement(self, *args):
        return _iDynTree.SensorsMeasurements_getMeasurement(self, *args)

    def getSizeOfAllSensorsMeasurements(self):
        return _iDynTree.SensorsMeasurements_getSizeOfAllSensorsMeasurements(self)

# Register SensorsMeasurements in _iDynTree:
_iDynTree.SensorsMeasurements_swigregister(SensorsMeasurements)

class SixAxisForceTorqueSensor(JointSensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.SixAxisForceTorqueSensor_swiginit(self, _iDynTree.new_SixAxisForceTorqueSensor(*args))
    __swig_destroy__ = _iDynTree.delete_SixAxisForceTorqueSensor

    def setName(self, _name):
        return _iDynTree.SixAxisForceTorqueSensor_setName(self, _name)

    def setFirstLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_setFirstLinkSensorTransform(self, link_index, link_H_sensor)

    def setSecondLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_setSecondLinkSensorTransform(self, link_index, link_H_sensor)

    def getFirstLinkIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getFirstLinkIndex(self)

    def getSecondLinkIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSecondLinkIndex(self)

    def setFirstLinkName(self, name):
        return _iDynTree.SixAxisForceTorqueSensor_setFirstLinkName(self, name)

    def setSecondLinkName(self, name):
        return _iDynTree.SixAxisForceTorqueSensor_setSecondLinkName(self, name)

    def getFirstLinkName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getFirstLinkName(self)

    def getSecondLinkName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSecondLinkName(self)

    def setParentJoint(self, parent):
        return _iDynTree.SixAxisForceTorqueSensor_setParentJoint(self, parent)

    def setParentJointIndex(self, parent_index):
        return _iDynTree.SixAxisForceTorqueSensor_setParentJointIndex(self, parent_index)

    def setAppliedWrenchLink(self, applied_wrench_index):
        return _iDynTree.SixAxisForceTorqueSensor_setAppliedWrenchLink(self, applied_wrench_index)

    def getName(self):
        return _iDynTree.SixAxisForceTorqueSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.SixAxisForceTorqueSensor_getSensorType(self)

    def getParentJoint(self):
        return _iDynTree.SixAxisForceTorqueSensor_getParentJoint(self)

    def getParentJointIndex(self):
        return _iDynTree.SixAxisForceTorqueSensor_getParentJointIndex(self)

    def isValid(self):
        return _iDynTree.SixAxisForceTorqueSensor_isValid(self)

    def clone(self):
        return _iDynTree.SixAxisForceTorqueSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.SixAxisForceTorqueSensor_updateIndices(self, model)

    def getAppliedWrenchLink(self):
        return _iDynTree.SixAxisForceTorqueSensor_getAppliedWrenchLink(self)

    def isLinkAttachedToSensor(self, link_index):
        return _iDynTree.SixAxisForceTorqueSensor_isLinkAttachedToSensor(self, link_index)

    def getLinkSensorTransform(self, link_index, link_H_sensor):
        return _iDynTree.SixAxisForceTorqueSensor_getLinkSensorTransform(self, link_index, link_H_sensor)

    def getWrenchAppliedOnLink(self, link_index, measured_wrench, wrench_applied_on_link):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLink(self, link_index, measured_wrench, wrench_applied_on_link)

    def getWrenchAppliedOnLinkMatrix(self, link_index, wrench_applied_on_link_matrix):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(self, link_index, wrench_applied_on_link_matrix)

    def getWrenchAppliedOnLinkInverseMatrix(self, link_index, wrench_applied_on_link_inverse_matrix):
        return _iDynTree.SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(self, link_index, wrench_applied_on_link_inverse_matrix)

    def predictMeasurement(self, traversal, intWrenches):
        return _iDynTree.SixAxisForceTorqueSensor_predictMeasurement(self, traversal, intWrenches)

    def toString(self, model):
        return _iDynTree.SixAxisForceTorqueSensor_toString(self, model)

# Register SixAxisForceTorqueSensor in _iDynTree:
_iDynTree.SixAxisForceTorqueSensor_swigregister(SixAxisForceTorqueSensor)

class AccelerometerSensor(LinkSensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.AccelerometerSensor_swiginit(self, _iDynTree.new_AccelerometerSensor(*args))
    __swig_destroy__ = _iDynTree.delete_AccelerometerSensor

    def setName(self, _name):
        return _iDynTree.AccelerometerSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.AccelerometerSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.AccelerometerSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.AccelerometerSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.AccelerometerSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.AccelerometerSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.AccelerometerSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.AccelerometerSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.AccelerometerSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.AccelerometerSensor_isValid(self)

    def clone(self):
        return _iDynTree.AccelerometerSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.AccelerometerSensor_updateIndices(self, model)

    def predictMeasurement(self, linkAcc, linkTwist):
        return _iDynTree.AccelerometerSensor_predictMeasurement(self, linkAcc, linkTwist)

# Register AccelerometerSensor in _iDynTree:
_iDynTree.AccelerometerSensor_swigregister(AccelerometerSensor)

class GyroscopeSensor(LinkSensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.GyroscopeSensor_swiginit(self, _iDynTree.new_GyroscopeSensor(*args))
    __swig_destroy__ = _iDynTree.delete_GyroscopeSensor

    def setName(self, _name):
        return _iDynTree.GyroscopeSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.GyroscopeSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.GyroscopeSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.GyroscopeSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.GyroscopeSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.GyroscopeSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.GyroscopeSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.GyroscopeSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.GyroscopeSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.GyroscopeSensor_isValid(self)

    def clone(self):
        return _iDynTree.GyroscopeSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.GyroscopeSensor_updateIndices(self, model)

    def predictMeasurement(self, linkVel):
        return _iDynTree.GyroscopeSensor_predictMeasurement(self, linkVel)

# Register GyroscopeSensor in _iDynTree:
_iDynTree.GyroscopeSensor_swigregister(GyroscopeSensor)

class ThreeAxisAngularAccelerometerSensor(LinkSensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.ThreeAxisAngularAccelerometerSensor_swiginit(self, _iDynTree.new_ThreeAxisAngularAccelerometerSensor(*args))
    __swig_destroy__ = _iDynTree.delete_ThreeAxisAngularAccelerometerSensor

    def setName(self, _name):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_isValid(self)

    def clone(self):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_updateIndices(self, model)

    def predictMeasurement(self, linkAcc):
        return _iDynTree.ThreeAxisAngularAccelerometerSensor_predictMeasurement(self, linkAcc)

# Register ThreeAxisAngularAccelerometerSensor in _iDynTree:
_iDynTree.ThreeAxisAngularAccelerometerSensor_swigregister(ThreeAxisAngularAccelerometerSensor)

class ThreeAxisForceTorqueContactSensor(LinkSensor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.ThreeAxisForceTorqueContactSensor_swiginit(self, _iDynTree.new_ThreeAxisForceTorqueContactSensor(*args))
    __swig_destroy__ = _iDynTree.delete_ThreeAxisForceTorqueContactSensor

    def setName(self, _name):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setName(self, _name)

    def setLinkSensorTransform(self, link_H_sensor):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(self, link_H_sensor)

    def setParentLink(self, parent):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setParentLink(self, parent)

    def setParentLinkIndex(self, parent_index):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setParentLinkIndex(self, parent_index)

    def getName(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getName(self)

    def getSensorType(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getSensorType(self)

    def getParentLink(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getParentLink(self)

    def getParentLinkIndex(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getParentLinkIndex(self)

    def getLinkSensorTransform(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(self)

    def isValid(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_isValid(self)

    def clone(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_clone(self)

    def updateIndices(self, model):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_updateIndices(self, model)

    def setLoadCellLocations(self, loadCellLocations):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_setLoadCellLocations(self, loadCellLocations)

    def getLoadCellLocations(self):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_getLoadCellLocations(self)

    def computeThreeAxisForceTorqueFromLoadCellMeasurements(self, loadCellMeasurements):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(self, loadCellMeasurements)

    def computeCenterOfPressureFromLoadCellMeasurements(self, loadCellMeasurements):
        return _iDynTree.ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(self, loadCellMeasurements)

# Register ThreeAxisForceTorqueContactSensor in _iDynTree:
_iDynTree.ThreeAxisForceTorqueContactSensor_swigregister(ThreeAxisForceTorqueContactSensor)


def predictSensorsMeasurements(model, sensorList, traversal, robotPos, robotVel, robotAcc, gravity, externalWrenches, buf_properRobotAcc, buf_linkPos, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, buf_outputTorques, predictedMeasurement):
    return _iDynTree.predictSensorsMeasurements(model, sensorList, traversal, robotPos, robotVel, robotAcc, gravity, externalWrenches, buf_properRobotAcc, buf_linkPos, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, buf_outputTorques, predictedMeasurement)

def predictSensorsMeasurementsFromRawBuffers(model, sensorList, traversal, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, predictedMeasurement):
    return _iDynTree.predictSensorsMeasurementsFromRawBuffers(model, sensorList, traversal, buf_linkVel, buf_linkProperAcc, buf_internalWrenches, predictedMeasurement)

def dofsListFromURDF(urdf_filename, dofs):
    return _iDynTree.dofsListFromURDF(urdf_filename, dofs)

def dofsListFromURDFString(urdf_string, dofs):
    return _iDynTree.dofsListFromURDFString(urdf_string, dofs)
class ModelParserOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    addSensorFramesAsAdditionalFrames = property(_iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_get, _iDynTree.ModelParserOptions_addSensorFramesAsAdditionalFrames_set)
    originalFilename = property(_iDynTree.ModelParserOptions_originalFilename_get, _iDynTree.ModelParserOptions_originalFilename_set)

    def __init__(self):
        _iDynTree.ModelParserOptions_swiginit(self, _iDynTree.new_ModelParserOptions())
    __swig_destroy__ = _iDynTree.delete_ModelParserOptions

# Register ModelParserOptions in _iDynTree:
_iDynTree.ModelParserOptions_swigregister(ModelParserOptions)

class ModelLoader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.ModelLoader_swiginit(self, _iDynTree.new_ModelLoader())
    __swig_destroy__ = _iDynTree.delete_ModelLoader

    def parsingOptions(self):
        return _iDynTree.ModelLoader_parsingOptions(self)

    def setParsingOptions(self, options):
        return _iDynTree.ModelLoader_setParsingOptions(self, options)

    def loadModelFromString(self, *args):
        return _iDynTree.ModelLoader_loadModelFromString(self, *args)

    def loadModelFromFile(self, *args):
        return _iDynTree.ModelLoader_loadModelFromFile(self, *args)

    def loadReducedModelFromFullModel(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromFullModel(self, *args)

    def loadReducedModelFromString(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromString(self, *args)

    def loadReducedModelFromFile(self, *args):
        return _iDynTree.ModelLoader_loadReducedModelFromFile(self, *args)

    def model(self):
        return _iDynTree.ModelLoader_model(self)

    def sensors(self):
        return _iDynTree.ModelLoader_sensors(self)

    def isValid(self):
        return _iDynTree.ModelLoader_isValid(self)

# Register ModelLoader in _iDynTree:
_iDynTree.ModelLoader_swigregister(ModelLoader)

class ModelExporterOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    baseLink = property(_iDynTree.ModelExporterOptions_baseLink_get, _iDynTree.ModelExporterOptions_baseLink_set)
    exportFirstBaseLinkAdditionalFrameAsFakeURDFBase = property(_iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get, _iDynTree.ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set)
    robotExportedName = property(_iDynTree.ModelExporterOptions_robotExportedName_get, _iDynTree.ModelExporterOptions_robotExportedName_set)

    def __init__(self):
        _iDynTree.ModelExporterOptions_swiginit(self, _iDynTree.new_ModelExporterOptions())
    __swig_destroy__ = _iDynTree.delete_ModelExporterOptions

# Register ModelExporterOptions in _iDynTree:
_iDynTree.ModelExporterOptions_swigregister(ModelExporterOptions)

class ModelExporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.ModelExporter_swiginit(self, _iDynTree.new_ModelExporter())
    __swig_destroy__ = _iDynTree.delete_ModelExporter

    def exportingOptions(self):
        return _iDynTree.ModelExporter_exportingOptions(self)

    def setExportingOptions(self, options):
        return _iDynTree.ModelExporter_setExportingOptions(self, options)

    def init(self, *args):
        return _iDynTree.ModelExporter_init(self, *args)

    def model(self):
        return _iDynTree.ModelExporter_model(self)

    def sensors(self):
        return _iDynTree.ModelExporter_sensors(self)

    def isValid(self):
        return _iDynTree.ModelExporter_isValid(self)

    def exportModelToString(self, *args):
        return _iDynTree.ModelExporter_exportModelToString(self, *args)

    def exportModelToFile(self, *args):
        return _iDynTree.ModelExporter_exportModelToFile(self, *args)

# Register ModelExporter in _iDynTree:
_iDynTree.ModelExporter_swigregister(ModelExporter)

class ModelCalibrationHelper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.ModelCalibrationHelper_swiginit(self, _iDynTree.new_ModelCalibrationHelper())
    __swig_destroy__ = _iDynTree.delete_ModelCalibrationHelper

    def loadModelFromString(self, *args):
        return _iDynTree.ModelCalibrationHelper_loadModelFromString(self, *args)

    def loadModelFromFile(self, *args):
        return _iDynTree.ModelCalibrationHelper_loadModelFromFile(self, *args)

    def updateModelInertialParametersToString(self, *args):
        return _iDynTree.ModelCalibrationHelper_updateModelInertialParametersToString(self, *args)

    def updateModelInertialParametersToFile(self, *args):
        return _iDynTree.ModelCalibrationHelper_updateModelInertialParametersToFile(self, *args)

    def model(self):
        return _iDynTree.ModelCalibrationHelper_model(self)

    def sensors(self):
        return _iDynTree.ModelCalibrationHelper_sensors(self)

    def isValid(self):
        return _iDynTree.ModelCalibrationHelper_isValid(self)

# Register ModelCalibrationHelper in _iDynTree:
_iDynTree.ModelCalibrationHelper_swigregister(ModelCalibrationHelper)

FULL_WRENCH = _iDynTree.FULL_WRENCH
PURE_FORCE = _iDynTree.PURE_FORCE
PURE_FORCE_WITH_KNOWN_DIRECTION = _iDynTree.PURE_FORCE_WITH_KNOWN_DIRECTION
NO_UNKNOWNS = _iDynTree.NO_UNKNOWNS
class UnknownWrenchContact(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.UnknownWrenchContact_swiginit(self, _iDynTree.new_UnknownWrenchContact(*args))
    unknownType = property(_iDynTree.UnknownWrenchContact_unknownType_get, _iDynTree.UnknownWrenchContact_unknownType_set)
    contactPoint = property(_iDynTree.UnknownWrenchContact_contactPoint_get, _iDynTree.UnknownWrenchContact_contactPoint_set)
    forceDirection = property(_iDynTree.UnknownWrenchContact_forceDirection_get, _iDynTree.UnknownWrenchContact_forceDirection_set)
    knownWrench = property(_iDynTree.UnknownWrenchContact_knownWrench_get, _iDynTree.UnknownWrenchContact_knownWrench_set)
    contactId = property(_iDynTree.UnknownWrenchContact_contactId_get, _iDynTree.UnknownWrenchContact_contactId_set)
    __swig_destroy__ = _iDynTree.delete_UnknownWrenchContact

# Register UnknownWrenchContact in _iDynTree:
_iDynTree.UnknownWrenchContact_swigregister(UnknownWrenchContact)

class LinkUnknownWrenchContacts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.LinkUnknownWrenchContacts_swiginit(self, _iDynTree.new_LinkUnknownWrenchContacts(*args))

    def clear(self):
        return _iDynTree.LinkUnknownWrenchContacts_clear(self)

    def resize(self, *args):
        return _iDynTree.LinkUnknownWrenchContacts_resize(self, *args)

    def getNrOfContactsForLink(self, linkIndex):
        return _iDynTree.LinkUnknownWrenchContacts_getNrOfContactsForLink(self, linkIndex)

    def setNrOfContactsForLink(self, linkIndex, nrOfContacts):
        return _iDynTree.LinkUnknownWrenchContacts_setNrOfContactsForLink(self, linkIndex, nrOfContacts)

    def addNewContactForLink(self, linkIndex, newContact):
        return _iDynTree.LinkUnknownWrenchContacts_addNewContactForLink(self, linkIndex, newContact)

    def addNewContactInFrame(self, model, frameIndex, newContact):
        return _iDynTree.LinkUnknownWrenchContacts_addNewContactInFrame(self, model, frameIndex, newContact)

    def addNewUnknownFullWrenchInFrameOrigin(self, model, frameIndex):
        return _iDynTree.LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin(self, model, frameIndex)

    def contactWrench(self, *args):
        return _iDynTree.LinkUnknownWrenchContacts_contactWrench(self, *args)

    def toString(self, model):
        return _iDynTree.LinkUnknownWrenchContacts_toString(self, model)
    __swig_destroy__ = _iDynTree.delete_LinkUnknownWrenchContacts

# Register LinkUnknownWrenchContacts in _iDynTree:
_iDynTree.LinkUnknownWrenchContacts_swigregister(LinkUnknownWrenchContacts)

class estimateExternalWrenchesBuffers(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _iDynTree.estimateExternalWrenchesBuffers_swiginit(self, _iDynTree.new_estimateExternalWrenchesBuffers(*args))

    def resize(self, *args):
        return _iDynTree.estimateExternalWrenchesBuffers_resize(self, *args)

    def getNrOfSubModels(self):
        return _iDynTree.estimateExternalWrenchesBuffers_getNrOfSubModels(self)

    def getNrOfLinks(self):
        return _iDynTree.estimateExternalWrenchesBuffers_getNrOfLinks(self)

    def isConsistent(self, subModels):
        return _iDynTree.estimateExternalWrenchesBuffers_isConsistent(self, subModels)
    A = property(_iDynTree.estimateExternalWrenchesBuffers_A_get, _iDynTree.estimateExternalWrenchesBuffers_A_set)
    x = property(_iDynTree.estimateExternalWrenchesBuffers_x_get, _iDynTree.estimateExternalWrenchesBuffers_x_set)
    b = property(_iDynTree.estimateExternalWrenchesBuffers_b_get, _iDynTree.estimateExternalWrenchesBuffers_b_set)
    pinvA = property(_iDynTree.estimateExternalWrenchesBuffers_pinvA_get, _iDynTree.estimateExternalWrenchesBuffers_pinvA_set)
    b_contacts_subtree = property(_iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_get, _iDynTree.estimateExternalWrenchesBuffers_b_contacts_subtree_set)
    subModelBase_H_link = property(_iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_get, _iDynTree.estimateExternalWrenchesBuffers_subModelBase_H_link_set)
    __swig_destroy__ = _iDynTree.delete_estimateExternalWrenchesBuffers

# Register estimateExternalWrenchesBuffers in _iDynTree:
_iDynTree.estimateExternalWrenchesBuffers_swigregister(estimateExternalWrenchesBuffers)


def estimateExternalWrenchesWithoutInternalFT(model, traversal, unknownWrenches, jointPos, linkVel, linkProperAcc, bufs, outputContactWrenches):
    return _iDynTree.estimateExternalWrenchesWithoutInternalFT(model, traversal, unknownWrenches, jointPos, linkVel, linkProperAcc, bufs, outputContactWrenches)

def estimateExternalWrenches(model, subModels, sensors, unknownWrenches, jointPos, linkVel, linkProperAcc, ftSensorsMeasurements, bufs, outputContactWrenches):
    return _iDynTree.estimateExternalWrenches(model, subModels, sensors, unknownWrenches, jointPos, linkVel, linkProperAcc, ftSensorsMeasurements, bufs, outputContactWrenches)

def dynamicsEstimationForwardVelAccKinematics(model, traversal, base_classicalProperAcc, base_angularVel, base_angularAcc, jointPos, jointVel, jointAcc, linkVel, linkProperAcc):
    return _iDynTree.dynamicsEstimationForwardVelAccKinematics(model, traversal, base_classicalProperAcc, base_angularVel, base_angularAcc, jointPos, jointVel, jointAcc, linkVel, linkProperAcc)

def dynamicsEstimationForwardVelKinematics(model, traversal, base_angularVel, jointPos, jointVel, linkVel):
    return _iDynTree.dynamicsEstimationForwardVelKinematics(model, traversal, base_angularVel, jointPos, jointVel, linkVel)

def computeLinkNetWrenchesWithoutGravity(model, linkVel, linkProperAcc, linkNetWrenchesWithoutGravity):
    return _iDynTree.computeLinkNetWrenchesWithoutGravity(model, linkVel, linkProperAcc, linkNetWrenchesWithoutGravity)

def estimateLinkContactWrenchesFromLinkNetExternalWrenches(model, unknownWrenches, netExtWrenches, outputContactWrenches):
    return _iDynTree.estimateLinkContactWrenchesFromLinkNetExternalWrenches(model, unknownWrenches, netExtWrenches, outputContactWrenches)
class ExtWrenchesAndJointTorquesEstimator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.ExtWrenchesAndJointTorquesEstimator_swiginit(self, _iDynTree.new_ExtWrenchesAndJointTorquesEstimator())
    __swig_destroy__ = _iDynTree.delete_ExtWrenchesAndJointTorquesEstimator

    def setModelAndSensors(self, _model, _sensors):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_setModelAndSensors(self, _model, _sensors)

    def loadModelAndSensorsFromFile(self, *args):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile(self, *args)

    def loadModelAndSensorsFromFileWithSpecifiedDOFs(self, *args):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs(self, *args)

    def model(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_model(self)

    def sensors(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_sensors(self)

    def submodels(self):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_submodels(self)

    def updateKinematicsFromFloatingBase(self, jointPos, jointVel, jointAcc, floatingFrame, properClassicalLinearAcceleration, angularVel, angularAcc):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase(self, jointPos, jointVel, jointAcc, floatingFrame, properClassicalLinearAcceleration, angularVel, angularAcc)

    def updateKinematicsFromFixedBase(self, jointPos, jointVel, jointAcc, fixedFrame, gravity):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase(self, jointPos, jointVel, jointAcc, fixedFrame, gravity)

    def computeExpectedFTSensorsMeasurements(self, unknowns, predictedMeasures, estimatedContactWrenches, estimatedJointTorques):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements(self, unknowns, predictedMeasures, estimatedContactWrenches, estimatedJointTorques)

    def estimateExtWrenchesAndJointTorques(self, unknowns, ftSensorsMeasures, estimatedContactWrenches, estimatedJointTorques):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques(self, unknowns, ftSensorsMeasures, estimatedContactWrenches, estimatedJointTorques)

    def checkThatTheModelIsStill(self, gravityNorm, properAccTol, verbose):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill(self, gravityNorm, properAccTol, verbose)

    def estimateLinkNetWrenchesWithoutGravity(self, netWrenches):
        return _iDynTree.ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity(self, netWrenches)

# Register ExtWrenchesAndJointTorquesEstimator in _iDynTree:
_iDynTree.ExtWrenchesAndJointTorquesEstimator_swigregister(ExtWrenchesAndJointTorquesEstimator)

class SimpleLeggedOdometry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.SimpleLeggedOdometry_swiginit(self, _iDynTree.new_SimpleLeggedOdometry())
    __swig_destroy__ = _iDynTree.delete_SimpleLeggedOdometry

    def setModel(self, _model):
        return _iDynTree.SimpleLeggedOdometry_setModel(self, _model)

    def model(self):
        return _iDynTree.SimpleLeggedOdometry_model(self)

    def updateKinematics(self, jointPos):
        return _iDynTree.SimpleLeggedOdometry_updateKinematics(self, jointPos)

    def init(self, *args):
        return _iDynTree.SimpleLeggedOdometry_init(self, *args)

    def changeFixedFrame(self, *args):
        return _iDynTree.SimpleLeggedOdometry_changeFixedFrame(self, *args)

    def getCurrentFixedLink(self):
        return _iDynTree.SimpleLeggedOdometry_getCurrentFixedLink(self)

    def getWorldLinkTransform(self, frame_index):
        return _iDynTree.SimpleLeggedOdometry_getWorldLinkTransform(self, frame_index)

    def getWorldFrameTransform(self, frame_index):
        return _iDynTree.SimpleLeggedOdometry_getWorldFrameTransform(self, frame_index)

# Register SimpleLeggedOdometry in _iDynTree:
_iDynTree.SimpleLeggedOdometry_swigregister(SimpleLeggedOdometry)

ORIGINAL_BERDY_FIXED_BASE = _iDynTree.ORIGINAL_BERDY_FIXED_BASE
BERDY_FLOATING_BASE = _iDynTree.BERDY_FLOATING_BASE
LINK_BODY_PROPER_ACCELERATION = _iDynTree.LINK_BODY_PROPER_ACCELERATION
NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV = _iDynTree.NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV
JOINT_WRENCH = _iDynTree.JOINT_WRENCH
DOF_TORQUE = _iDynTree.DOF_TORQUE
NET_EXT_WRENCH = _iDynTree.NET_EXT_WRENCH
DOF_ACCELERATION = _iDynTree.DOF_ACCELERATION
LINK_BODY_PROPER_CLASSICAL_ACCELERATION = _iDynTree.LINK_BODY_PROPER_CLASSICAL_ACCELERATION
SIX_AXIS_FORCE_TORQUE_SENSOR = _iDynTree.SIX_AXIS_FORCE_TORQUE_SENSOR
ACCELEROMETER_SENSOR = _iDynTree.ACCELEROMETER_SENSOR
GYROSCOPE_SENSOR = _iDynTree.GYROSCOPE_SENSOR
THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR = _iDynTree.THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR
THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR = _iDynTree.THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR
DOF_ACCELERATION_SENSOR = _iDynTree.DOF_ACCELERATION_SENSOR
DOF_TORQUE_SENSOR = _iDynTree.DOF_TORQUE_SENSOR
NET_EXT_WRENCH_SENSOR = _iDynTree.NET_EXT_WRENCH_SENSOR
JOINT_WRENCH_SENSOR = _iDynTree.JOINT_WRENCH_SENSOR

def isLinkBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isLinkBerdyDynamicVariable(dynamicVariableType)

def isJointBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isJointBerdyDynamicVariable(dynamicVariableType)

def isDOFBerdyDynamicVariable(dynamicVariableType):
    return _iDynTree.isDOFBerdyDynamicVariable(dynamicVariableType)
class BerdyOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.BerdyOptions_swiginit(self, _iDynTree.new_BerdyOptions())
    berdyVariant = property(_iDynTree.BerdyOptions_berdyVariant_get, _iDynTree.BerdyOptions_berdyVariant_set)
    includeAllNetExternalWrenchesAsDynamicVariables = property(_iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get, _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set)
    includeAllJointAccelerationsAsSensors = property(_iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_get, _iDynTree.BerdyOptions_includeAllJointAccelerationsAsSensors_set)
    includeAllJointTorquesAsSensors = property(_iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_get, _iDynTree.BerdyOptions_includeAllJointTorquesAsSensors_set)
    includeAllNetExternalWrenchesAsSensors = property(_iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_get, _iDynTree.BerdyOptions_includeAllNetExternalWrenchesAsSensors_set)
    includeFixedBaseExternalWrench = property(_iDynTree.BerdyOptions_includeFixedBaseExternalWrench_get, _iDynTree.BerdyOptions_includeFixedBaseExternalWrench_set)
    jointOnWhichTheInternalWrenchIsMeasured = property(_iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get, _iDynTree.BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set)
    baseLink = property(_iDynTree.BerdyOptions_baseLink_get, _iDynTree.BerdyOptions_baseLink_set)

    def checkConsistency(self):
        return _iDynTree.BerdyOptions_checkConsistency(self)
    __swig_destroy__ = _iDynTree.delete_BerdyOptions

# Register BerdyOptions in _iDynTree:
_iDynTree.BerdyOptions_swigregister(BerdyOptions)

class BerdySensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_iDynTree.BerdySensor_type_get, _iDynTree.BerdySensor_type_set)
    id = property(_iDynTree.BerdySensor_id_get, _iDynTree.BerdySensor_id_set)
    range = property(_iDynTree.BerdySensor_range_get, _iDynTree.BerdySensor_range_set)

    def __eq__(self, sensor):
        return _iDynTree.BerdySensor___eq__(self, sensor)

    def __lt__(self, sensor):
        return _iDynTree.BerdySensor___lt__(self, sensor)

    def __init__(self):
        _iDynTree.BerdySensor_swiginit(self, _iDynTree.new_BerdySensor())
    __swig_destroy__ = _iDynTree.delete_BerdySensor

# Register BerdySensor in _iDynTree:
_iDynTree.BerdySensor_swigregister(BerdySensor)

class BerdyDynamicVariable(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_iDynTree.BerdyDynamicVariable_type_get, _iDynTree.BerdyDynamicVariable_type_set)
    id = property(_iDynTree.BerdyDynamicVariable_id_get, _iDynTree.BerdyDynamicVariable_id_set)
    range = property(_iDynTree.BerdyDynamicVariable_range_get, _iDynTree.BerdyDynamicVariable_range_set)

    def __eq__(self, variable):
        return _iDynTree.BerdyDynamicVariable___eq__(self, variable)

    def __lt__(self, variable):
        return _iDynTree.BerdyDynamicVariable___lt__(self, variable)

    def __init__(self):
        _iDynTree.BerdyDynamicVariable_swiginit(self, _iDynTree.new_BerdyDynamicVariable())
    __swig_destroy__ = _iDynTree.delete_BerdyDynamicVariable

# Register BerdyDynamicVariable in _iDynTree:
_iDynTree.BerdyDynamicVariable_swigregister(BerdyDynamicVariable)

class BerdyHelper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.BerdyHelper_swiginit(self, _iDynTree.new_BerdyHelper())

    def dynamicTraversal(self):
        return _iDynTree.BerdyHelper_dynamicTraversal(self)

    def model(self, *args):
        return _iDynTree.BerdyHelper_model(self, *args)

    def sensors(self, *args):
        return _iDynTree.BerdyHelper_sensors(self, *args)

    def isValid(self):
        return _iDynTree.BerdyHelper_isValid(self)

    def init(self, *args):
        return _iDynTree.BerdyHelper_init(self, *args)

    def getOptions(self):
        return _iDynTree.BerdyHelper_getOptions(self)

    def getNrOfDynamicVariables(self):
        return _iDynTree.BerdyHelper_getNrOfDynamicVariables(self)

    def getNrOfDynamicEquations(self):
        return _iDynTree.BerdyHelper_getNrOfDynamicEquations(self)

    def getNrOfSensorsMeasurements(self):
        return _iDynTree.BerdyHelper_getNrOfSensorsMeasurements(self)

    def resizeAndZeroBerdyMatrices(self, *args):
        return _iDynTree.BerdyHelper_resizeAndZeroBerdyMatrices(self, *args)

    def getBerdyMatrices(self, *args):
        return _iDynTree.BerdyHelper_getBerdyMatrices(self, *args)

    def getSensorsOrdering(self):
        return _iDynTree.BerdyHelper_getSensorsOrdering(self)

    def getRangeSensorVariable(self, type, sensorIdx):
        return _iDynTree.BerdyHelper_getRangeSensorVariable(self, type, sensorIdx)

    def getRangeDOFSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeDOFSensorVariable(self, sensorType, idx)

    def getRangeJointSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeJointSensorVariable(self, sensorType, idx)

    def getRangeLinkSensorVariable(self, sensorType, idx):
        return _iDynTree.BerdyHelper_getRangeLinkSensorVariable(self, sensorType, idx)

    def getRangeLinkVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeLinkVariable(self, dynamicVariableType, idx)

    def getRangeJointVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeJointVariable(self, dynamicVariableType, idx)

    def getRangeDOFVariable(self, dynamicVariableType, idx):
        return _iDynTree.BerdyHelper_getRangeDOFVariable(self, dynamicVariableType, idx)

    def getDynamicVariablesOrdering(self):
        return _iDynTree.BerdyHelper_getDynamicVariablesOrdering(self)

    def serializeDynamicVariables(self, properAccs, netTotalWrenchesWithoutGrav, netExtWrenches, linkJointWrenches, jointTorques, jointAccs, d):
        return _iDynTree.BerdyHelper_serializeDynamicVariables(self, properAccs, netTotalWrenchesWithoutGrav, netExtWrenches, linkJointWrenches, jointTorques, jointAccs, d)

    def serializeSensorVariables(self, sensMeas, netExtWrenches, jointTorques, jointAccs, linkJointWrenches, y):
        return _iDynTree.BerdyHelper_serializeSensorVariables(self, sensMeas, netExtWrenches, jointTorques, jointAccs, linkJointWrenches, y)

    def serializeDynamicVariablesComputedFromFixedBaseRNEA(self, jointAccs, netExtWrenches, d):
        return _iDynTree.BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA(self, jointAccs, netExtWrenches, d)

    def extractJointTorquesFromDynamicVariables(self, d, jointPos, jointTorques):
        return _iDynTree.BerdyHelper_extractJointTorquesFromDynamicVariables(self, d, jointPos, jointTorques)

    def extractLinkNetExternalWrenchesFromDynamicVariables(self, d, netExtWrenches):
        return _iDynTree.BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables(self, d, netExtWrenches)

    def updateKinematicsFromFloatingBase(self, jointPos, jointVel, floatingFrame, angularVel):
        return _iDynTree.BerdyHelper_updateKinematicsFromFloatingBase(self, jointPos, jointVel, floatingFrame, angularVel)

    def updateKinematicsFromFixedBase(self, jointPos, jointVel, fixedFrame, gravity):
        return _iDynTree.BerdyHelper_updateKinematicsFromFixedBase(self, jointPos, jointVel, fixedFrame, gravity)

    def updateKinematicsFromTraversalFixedBase(self, jointPos, jointVel, gravity):
        return _iDynTree.BerdyHelper_updateKinematicsFromTraversalFixedBase(self, jointPos, jointVel, gravity)

    def setNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact):
        return _iDynTree.BerdyHelper_setNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact)

    def getNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact):
        return _iDynTree.BerdyHelper_getNetExternalWrenchMeasurementFrame(self, lnkIndex, link_H_contact)
    __swig_destroy__ = _iDynTree.delete_BerdyHelper

# Register BerdyHelper in _iDynTree:
_iDynTree.BerdyHelper_swigregister(BerdyHelper)

class BerdySparseMAPSolver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, berdyHelper):
        _iDynTree.BerdySparseMAPSolver_swiginit(self, _iDynTree.new_BerdySparseMAPSolver(berdyHelper))
    __swig_destroy__ = _iDynTree.delete_BerdySparseMAPSolver

    def setDynamicsConstraintsPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance(self, covariance)

    def setDynamicsRegularizationPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance(self, covariance)

    def setDynamicsRegularizationPriorExpectedValue(self, expectedValue):
        return _iDynTree.BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue(self, expectedValue)

    def setMeasurementsPriorCovariance(self, covariance):
        return _iDynTree.BerdySparseMAPSolver_setMeasurementsPriorCovariance(self, covariance)

    def dynamicsConstraintsPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse(self, *args)

    def dynamicsRegularizationPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse(self, *args)

    def dynamicsRegularizationPriorExpectedValue(self, *args):
        return _iDynTree.BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue(self, *args)

    def measurementsPriorCovarianceInverse(self, *args):
        return _iDynTree.BerdySparseMAPSolver_measurementsPriorCovarianceInverse(self, *args)

    def isValid(self):
        return _iDynTree.BerdySparseMAPSolver_isValid(self)

    def initialize(self):
        return _iDynTree.BerdySparseMAPSolver_initialize(self)

    def updateEstimateInformationFixedBase(self, jointsConfiguration, jointsVelocity, fixedFrame, gravityInFixedFrame, measurements):
        return _iDynTree.BerdySparseMAPSolver_updateEstimateInformationFixedBase(self, jointsConfiguration, jointsVelocity, fixedFrame, gravityInFixedFrame, measurements)

    def updateEstimateInformationFloatingBase(self, jointsConfiguration, jointsVelocity, floatingFrame, bodyAngularVelocityOfSpecifiedFrame, measurements):
        return _iDynTree.BerdySparseMAPSolver_updateEstimateInformationFloatingBase(self, jointsConfiguration, jointsVelocity, floatingFrame, bodyAngularVelocityOfSpecifiedFrame, measurements)

    def doEstimate(self):
        return _iDynTree.BerdySparseMAPSolver_doEstimate(self)

    def getLastEstimate(self, *args):
        return _iDynTree.BerdySparseMAPSolver_getLastEstimate(self, *args)

# Register BerdySparseMAPSolver in _iDynTree:
_iDynTree.BerdySparseMAPSolver_swigregister(BerdySparseMAPSolver)

class AttitudeEstimatorState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_orientation = property(_iDynTree.AttitudeEstimatorState_m_orientation_get, _iDynTree.AttitudeEstimatorState_m_orientation_set)
    m_angular_velocity = property(_iDynTree.AttitudeEstimatorState_m_angular_velocity_get, _iDynTree.AttitudeEstimatorState_m_angular_velocity_set)
    m_gyroscope_bias = property(_iDynTree.AttitudeEstimatorState_m_gyroscope_bias_get, _iDynTree.AttitudeEstimatorState_m_gyroscope_bias_set)

    def __init__(self):
        _iDynTree.AttitudeEstimatorState_swiginit(self, _iDynTree.new_AttitudeEstimatorState())
    __swig_destroy__ = _iDynTree.delete_AttitudeEstimatorState

# Register AttitudeEstimatorState in _iDynTree:
_iDynTree.AttitudeEstimatorState_swigregister(AttitudeEstimatorState)

class IAttitudeEstimator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IAttitudeEstimator

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.IAttitudeEstimator_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.IAttitudeEstimator_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.IAttitudeEstimator_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.IAttitudeEstimator_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.IAttitudeEstimator_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.IAttitudeEstimator_setInternalStateInitialOrientation(self, orientationBuffer)

# Register IAttitudeEstimator in _iDynTree:
_iDynTree.IAttitudeEstimator_swigregister(IAttitudeEstimator)

class AttitudeMahonyFilterParameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time_step_in_seconds = property(_iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_get, _iDynTree.AttitudeMahonyFilterParameters_time_step_in_seconds_set)
    kp = property(_iDynTree.AttitudeMahonyFilterParameters_kp_get, _iDynTree.AttitudeMahonyFilterParameters_kp_set)
    ki = property(_iDynTree.AttitudeMahonyFilterParameters_ki_get, _iDynTree.AttitudeMahonyFilterParameters_ki_set)
    use_magnetometer_measurements = property(_iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_get, _iDynTree.AttitudeMahonyFilterParameters_use_magnetometer_measurements_set)
    confidence_magnetometer_measurements = property(_iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get, _iDynTree.AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set)

    def __init__(self):
        _iDynTree.AttitudeMahonyFilterParameters_swiginit(self, _iDynTree.new_AttitudeMahonyFilterParameters())
    __swig_destroy__ = _iDynTree.delete_AttitudeMahonyFilterParameters

# Register AttitudeMahonyFilterParameters in _iDynTree:
_iDynTree.AttitudeMahonyFilterParameters_swigregister(AttitudeMahonyFilterParameters)

class AttitudeMahonyFilter(IAttitudeEstimator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.AttitudeMahonyFilter_swiginit(self, _iDynTree.new_AttitudeMahonyFilter())

    def useMagnetoMeterMeasurements(self, flag):
        return _iDynTree.AttitudeMahonyFilter_useMagnetoMeterMeasurements(self, flag)

    def setConfidenceForMagnetometerMeasurements(self, confidence):
        return _iDynTree.AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements(self, confidence)

    def setGainkp(self, kp):
        return _iDynTree.AttitudeMahonyFilter_setGainkp(self, kp)

    def setGainki(self, ki):
        return _iDynTree.AttitudeMahonyFilter_setGainki(self, ki)

    def setTimeStepInSeconds(self, timestepInSeconds):
        return _iDynTree.AttitudeMahonyFilter_setTimeStepInSeconds(self, timestepInSeconds)

    def setGravityDirection(self, gravity_dir):
        return _iDynTree.AttitudeMahonyFilter_setGravityDirection(self, gravity_dir)

    def setParameters(self, params):
        return _iDynTree.AttitudeMahonyFilter_setParameters(self, params)

    def getParameters(self, params):
        return _iDynTree.AttitudeMahonyFilter_getParameters(self, params)

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.AttitudeMahonyFilter_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.AttitudeMahonyFilter_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.AttitudeMahonyFilter_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.AttitudeMahonyFilter_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.AttitudeMahonyFilter_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.AttitudeMahonyFilter_setInternalStateInitialOrientation(self, orientationBuffer)
    __swig_destroy__ = _iDynTree.delete_AttitudeMahonyFilter

# Register AttitudeMahonyFilter in _iDynTree:
_iDynTree.AttitudeMahonyFilter_swigregister(AttitudeMahonyFilter)

class DiscreteExtendedKalmanFilterHelper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ekf_f(self, x_k, u_k, xhat_k_plus_one):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekf_f(self, x_k, u_k, xhat_k_plus_one)

    def ekf_h(self, xhat_k_plus_one, zhat_k_plus_one):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekf_h(self, xhat_k_plus_one, zhat_k_plus_one)

    def ekfComputeJacobianF(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF(self, *args)

    def ekfComputeJacobianH(self, x, H):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH(self, x, H)

    def ekfPredict(self):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfPredict(self)

    def ekfUpdate(self):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfUpdate(self)

    def ekfInit(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfInit(self, *args)

    def ekfReset(self, *args):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfReset(self, *args)

    def ekfSetMeasurementVector(self, y):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector(self, y)

    def ekfSetInputVector(self, u):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInputVector(self, u)

    def ekfSetInitialState(self, x0):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInitialState(self, x0)

    def ekfSetStateCovariance(self, P):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance(self, P)

    def ekfSetSystemNoiseCovariance(self, Q):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance(self, Q)

    def ekfSetMeasurementNoiseCovariance(self, R):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance(self, R)

    def ekfSetStateSize(self, dim_X):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetStateSize(self, dim_X)

    def ekfSetInputSize(self, dim_U):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetInputSize(self, dim_U)

    def ekfSetOutputSize(self, dim_Y):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize(self, dim_Y)

    def ekfGetStates(self, x):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfGetStates(self, x)

    def ekfGetStateCovariance(self, P):
        return _iDynTree.DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance(self, P)
    __swig_destroy__ = _iDynTree.delete_DiscreteExtendedKalmanFilterHelper

# Register DiscreteExtendedKalmanFilterHelper in _iDynTree:
_iDynTree.DiscreteExtendedKalmanFilterHelper_swigregister(DiscreteExtendedKalmanFilterHelper)

class AttitudeQuaternionEKFParameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time_step_in_seconds = property(_iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_get, _iDynTree.AttitudeQuaternionEKFParameters_time_step_in_seconds_set)
    bias_correlation_time_factor = property(_iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get, _iDynTree.AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set)
    accelerometer_noise_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set)
    magnetometer_noise_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set)
    gyroscope_noise_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set)
    gyro_bias_noise_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set)
    initial_orientation_error_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set)
    initial_ang_vel_error_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set)
    initial_gyro_bias_error_variance = property(_iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get, _iDynTree.AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set)
    use_magnetometer_measurements = property(_iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get, _iDynTree.AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set)

    def __init__(self):
        _iDynTree.AttitudeQuaternionEKFParameters_swiginit(self, _iDynTree.new_AttitudeQuaternionEKFParameters())
    __swig_destroy__ = _iDynTree.delete_AttitudeQuaternionEKFParameters

# Register AttitudeQuaternionEKFParameters in _iDynTree:
_iDynTree.AttitudeQuaternionEKFParameters_swigregister(AttitudeQuaternionEKFParameters)
output_dimensions_with_magnetometer = cvar.output_dimensions_with_magnetometer
output_dimensions_without_magnetometer = cvar.output_dimensions_without_magnetometer
input_dimensions = cvar.input_dimensions

class AttitudeQuaternionEKF(IAttitudeEstimator, DiscreteExtendedKalmanFilterHelper):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.AttitudeQuaternionEKF_swiginit(self, _iDynTree.new_AttitudeQuaternionEKF())

    def getParameters(self, params):
        return _iDynTree.AttitudeQuaternionEKF_getParameters(self, params)

    def setParameters(self, params):
        return _iDynTree.AttitudeQuaternionEKF_setParameters(self, params)

    def setGravityDirection(self, gravity_dir):
        return _iDynTree.AttitudeQuaternionEKF_setGravityDirection(self, gravity_dir)

    def setTimeStepInSeconds(self, time_step_in_seconds):
        return _iDynTree.AttitudeQuaternionEKF_setTimeStepInSeconds(self, time_step_in_seconds)

    def setBiasCorrelationTimeFactor(self, bias_correlation_time_factor):
        return _iDynTree.AttitudeQuaternionEKF_setBiasCorrelationTimeFactor(self, bias_correlation_time_factor)

    def useMagnetometerMeasurements(self, use_magnetometer_measurements):
        return _iDynTree.AttitudeQuaternionEKF_useMagnetometerMeasurements(self, use_magnetometer_measurements)

    def setMeasurementNoiseVariance(self, acc, mag):
        return _iDynTree.AttitudeQuaternionEKF_setMeasurementNoiseVariance(self, acc, mag)

    def setSystemNoiseVariance(self, gyro, gyro_bias):
        return _iDynTree.AttitudeQuaternionEKF_setSystemNoiseVariance(self, gyro, gyro_bias)

    def setInitialStateCovariance(self, orientation_var, ang_vel_var, gyro_bias_var):
        return _iDynTree.AttitudeQuaternionEKF_setInitialStateCovariance(self, orientation_var, ang_vel_var, gyro_bias_var)

    def initializeFilter(self):
        return _iDynTree.AttitudeQuaternionEKF_initializeFilter(self)

    def updateFilterWithMeasurements(self, *args):
        return _iDynTree.AttitudeQuaternionEKF_updateFilterWithMeasurements(self, *args)

    def propagateStates(self):
        return _iDynTree.AttitudeQuaternionEKF_propagateStates(self)

    def getOrientationEstimateAsRotationMatrix(self, rot):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix(self, rot)

    def getOrientationEstimateAsQuaternion(self, q):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion(self, q)

    def getOrientationEstimateAsRPY(self, rpy):
        return _iDynTree.AttitudeQuaternionEKF_getOrientationEstimateAsRPY(self, rpy)

    def getInternalStateSize(self):
        return _iDynTree.AttitudeQuaternionEKF_getInternalStateSize(self)

    def getInternalState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_getInternalState(self, stateBuffer)

    def getDefaultInternalInitialState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_getDefaultInternalInitialState(self, stateBuffer)

    def setInternalState(self, stateBuffer):
        return _iDynTree.AttitudeQuaternionEKF_setInternalState(self, stateBuffer)

    def setInternalStateInitialOrientation(self, orientationBuffer):
        return _iDynTree.AttitudeQuaternionEKF_setInternalStateInitialOrientation(self, orientationBuffer)
    __swig_destroy__ = _iDynTree.delete_AttitudeQuaternionEKF

# Register AttitudeQuaternionEKF in _iDynTree:
_iDynTree.AttitudeQuaternionEKF_swigregister(AttitudeQuaternionEKF)


def estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(totalMass, model, estimatedInertialParams):
    return _iDynTree.estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(totalMass, model, estimatedInertialParams)

def computeBoundingBoxFromShape(geom, box):
    return _iDynTree.computeBoundingBoxFromShape(geom, box)

def computeBoxVertices(box):
    return _iDynTree.computeBoxVertices(box)
class KinDynComputations(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.KinDynComputations_swiginit(self, _iDynTree.new_KinDynComputations())
    __swig_destroy__ = _iDynTree.delete_KinDynComputations

    def loadRobotModel(self, model):
        return _iDynTree.KinDynComputations_loadRobotModel(self, model)

    def isValid(self):
        return _iDynTree.KinDynComputations_isValid(self)

    def setFrameVelocityRepresentation(self, frameVelRepr):
        return _iDynTree.KinDynComputations_setFrameVelocityRepresentation(self, frameVelRepr)

    def getFrameVelocityRepresentation(self):
        return _iDynTree.KinDynComputations_getFrameVelocityRepresentation(self)

    def getNrOfDegreesOfFreedom(self):
        return _iDynTree.KinDynComputations_getNrOfDegreesOfFreedom(self)

    def getDescriptionOfDegreeOfFreedom(self, dof_index):
        return _iDynTree.KinDynComputations_getDescriptionOfDegreeOfFreedom(self, dof_index)

    def getDescriptionOfDegreesOfFreedom(self):
        return _iDynTree.KinDynComputations_getDescriptionOfDegreesOfFreedom(self)

    def getNrOfLinks(self):
        return _iDynTree.KinDynComputations_getNrOfLinks(self)

    def getNrOfFrames(self):
        return _iDynTree.KinDynComputations_getNrOfFrames(self)

    def getFloatingBase(self):
        return _iDynTree.KinDynComputations_getFloatingBase(self)

    def setFloatingBase(self, floatingBaseName):
        return _iDynTree.KinDynComputations_setFloatingBase(self, floatingBaseName)

    def model(self):
        return _iDynTree.KinDynComputations_model(self)

    def getRobotModel(self):
        return _iDynTree.KinDynComputations_getRobotModel(self)

    def getRelativeJacobianSparsityPattern(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobianSparsityPattern(self, *args)

    def getFrameFreeFloatingJacobianSparsityPattern(self, *args):
        return _iDynTree.KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern(self, *args)

    def setJointPos(self, *args):
        return _iDynTree.KinDynComputations_setJointPos(self, *args)

    def setRobotState(self, *args):
        return _iDynTree.KinDynComputations_setRobotState(self, *args)

    def getRobotState(self, *args):
        return _iDynTree.KinDynComputations_getRobotState(self, *args)

    def getWorldBaseTransform(self, *args):
        return _iDynTree.KinDynComputations_getWorldBaseTransform(self, *args)

    def getBaseTwist(self, *args):
        return _iDynTree.KinDynComputations_getBaseTwist(self, *args)

    def getJointPos(self, *args):
        return _iDynTree.KinDynComputations_getJointPos(self, *args)

    def getJointVel(self, *args):
        return _iDynTree.KinDynComputations_getJointVel(self, *args)

    def getModelVel(self, *args):
        return _iDynTree.KinDynComputations_getModelVel(self, *args)

    def getFrameIndex(self, frameName):
        return _iDynTree.KinDynComputations_getFrameIndex(self, frameName)

    def getFrameName(self, frameIndex):
        return _iDynTree.KinDynComputations_getFrameName(self, frameIndex)

    def getWorldTransform(self, *args):
        return _iDynTree.KinDynComputations_getWorldTransform(self, *args)

    def getWorldTransformsAsHomogeneous(self, frameNames):
        return _iDynTree.KinDynComputations_getWorldTransformsAsHomogeneous(self, frameNames)

    def getRelativeTransformExplicit(self, *args):
        return _iDynTree.KinDynComputations_getRelativeTransformExplicit(self, *args)

    def getRelativeTransform(self, *args):
        return _iDynTree.KinDynComputations_getRelativeTransform(self, *args)

    def getFrameVel(self, *args):
        return _iDynTree.KinDynComputations_getFrameVel(self, *args)

    def getFrameAcc(self, *args):
        return _iDynTree.KinDynComputations_getFrameAcc(self, *args)

    def getFrameFreeFloatingJacobian(self, *args):
        return _iDynTree.KinDynComputations_getFrameFreeFloatingJacobian(self, *args)

    def getRelativeJacobian(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobian(self, *args)

    def getRelativeJacobianExplicit(self, *args):
        return _iDynTree.KinDynComputations_getRelativeJacobianExplicit(self, *args)

    def getFrameBiasAcc(self, *args):
        return _iDynTree.KinDynComputations_getFrameBiasAcc(self, *args)

    def getCenterOfMassPosition(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassPosition(self, *args)

    def getCenterOfMassVelocity(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassVelocity(self, *args)

    def getCenterOfMassJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassJacobian(self, *args)

    def getCenterOfMassBiasAcc(self, *args):
        return _iDynTree.KinDynComputations_getCenterOfMassBiasAcc(self, *args)

    def getAverageVelocity(self, *args):
        return _iDynTree.KinDynComputations_getAverageVelocity(self, *args)

    def getAverageVelocityJacobian(self, *args):
        return _iDynTree.KinDynComputations_getAverageVelocityJacobian(self, *args)

    def getCentroidalAverageVelocity(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalAverageVelocity(self, *args)

    def getCentroidalAverageVelocityJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalAverageVelocityJacobian(self, *args)

    def getLinearAngularMomentum(self, *args):
        return _iDynTree.KinDynComputations_getLinearAngularMomentum(self, *args)

    def getLinearAngularMomentumJacobian(self, *args):
        return _iDynTree.KinDynComputations_getLinearAngularMomentumJacobian(self, *args)

    def getCentroidalTotalMomentum(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalTotalMomentum(self, *args)

    def getCentroidalTotalMomentumJacobian(self, *args):
        return _iDynTree.KinDynComputations_getCentroidalTotalMomentumJacobian(self, *args)

    def getFreeFloatingMassMatrix(self, *args):
        return _iDynTree.KinDynComputations_getFreeFloatingMassMatrix(self, *args)

    def inverseDynamics(self, *args):
        return _iDynTree.KinDynComputations_inverseDynamics(self, *args)

    def inverseDynamicsWithInternalJointForceTorques(self, *args):
        return _iDynTree.KinDynComputations_inverseDynamicsWithInternalJointForceTorques(self, *args)

    def generalizedBiasForces(self, *args):
        return _iDynTree.KinDynComputations_generalizedBiasForces(self, *args)

    def generalizedGravityForces(self, *args):
        return _iDynTree.KinDynComputations_generalizedGravityForces(self, *args)

    def generalizedExternalForces(self, linkExtForces, generalizedExternalForces):
        return _iDynTree.KinDynComputations_generalizedExternalForces(self, linkExtForces, generalizedExternalForces)

    def inverseDynamicsInertialParametersRegressor(self, baseAcc, s_ddot, baseForceAndJointTorquesRegressor):
        return _iDynTree.KinDynComputations_inverseDynamicsInertialParametersRegressor(self, baseAcc, s_ddot, baseForceAndJointTorquesRegressor)

# Register KinDynComputations in _iDynTree:
_iDynTree.KinDynComputations_swigregister(KinDynComputations)

class Matrix4x4Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _iDynTree.Matrix4x4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _iDynTree.Matrix4x4Vector___nonzero__(self)

    def __bool__(self):
        return _iDynTree.Matrix4x4Vector___bool__(self)

    def __len__(self):
        return _iDynTree.Matrix4x4Vector___len__(self)

    def __getslice__(self, i, j):
        return _iDynTree.Matrix4x4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _iDynTree.Matrix4x4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _iDynTree.Matrix4x4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _iDynTree.Matrix4x4Vector___setitem__(self, *args)

    def pop(self):
        return _iDynTree.Matrix4x4Vector_pop(self)

    def append(self, x):
        return _iDynTree.Matrix4x4Vector_append(self, x)

    def empty(self):
        return _iDynTree.Matrix4x4Vector_empty(self)

    def size(self):
        return _iDynTree.Matrix4x4Vector_size(self)

    def swap(self, v):
        return _iDynTree.Matrix4x4Vector_swap(self, v)

    def begin(self):
        return _iDynTree.Matrix4x4Vector_begin(self)

    def end(self):
        return _iDynTree.Matrix4x4Vector_end(self)

    def rbegin(self):
        return _iDynTree.Matrix4x4Vector_rbegin(self)

    def rend(self):
        return _iDynTree.Matrix4x4Vector_rend(self)

    def clear(self):
        return _iDynTree.Matrix4x4Vector_clear(self)

    def get_allocator(self):
        return _iDynTree.Matrix4x4Vector_get_allocator(self)

    def pop_back(self):
        return _iDynTree.Matrix4x4Vector_pop_back(self)

    def erase(self, *args):
        return _iDynTree.Matrix4x4Vector_erase(self, *args)

    def __init__(self, *args):
        _iDynTree.Matrix4x4Vector_swiginit(self, _iDynTree.new_Matrix4x4Vector(*args))

    def push_back(self, x):
        return _iDynTree.Matrix4x4Vector_push_back(self, x)

    def front(self):
        return _iDynTree.Matrix4x4Vector_front(self)

    def back(self):
        return _iDynTree.Matrix4x4Vector_back(self)

    def assign(self, n, x):
        return _iDynTree.Matrix4x4Vector_assign(self, n, x)

    def resize(self, *args):
        return _iDynTree.Matrix4x4Vector_resize(self, *args)

    def insert(self, *args):
        return _iDynTree.Matrix4x4Vector_insert(self, *args)

    def reserve(self, n):
        return _iDynTree.Matrix4x4Vector_reserve(self, n)

    def capacity(self):
        return _iDynTree.Matrix4x4Vector_capacity(self)
    __swig_destroy__ = _iDynTree.delete_Matrix4x4Vector

# Register Matrix4x4Vector in _iDynTree:
_iDynTree.Matrix4x4Vector_swigregister(Matrix4x4Vector)

class ICameraAnimator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def enableMouseControl(self, enabled=True):
        return _iDynTree.ICameraAnimator_enableMouseControl(self, enabled)

    def getMoveSpeed(self):
        return _iDynTree.ICameraAnimator_getMoveSpeed(self)

    def setMoveSpeed(self, moveSpeed):
        return _iDynTree.ICameraAnimator_setMoveSpeed(self, moveSpeed)

    def getRotateSpeed(self):
        return _iDynTree.ICameraAnimator_getRotateSpeed(self)

    def setRotateSpeed(self, rotateSpeed):
        return _iDynTree.ICameraAnimator_setRotateSpeed(self, rotateSpeed)

    def getZoomSpeed(self):
        return _iDynTree.ICameraAnimator_getZoomSpeed(self)

    def setZoomSpeed(self, zoomSpeed):
        return _iDynTree.ICameraAnimator_setZoomSpeed(self, zoomSpeed)
    __swig_destroy__ = _iDynTree.delete_ICameraAnimator

# Register ICameraAnimator in _iDynTree:
_iDynTree.ICameraAnimator_swigregister(ICameraAnimator)

class ICamera(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ICamera

    def setPosition(self, cameraPos):
        return _iDynTree.ICamera_setPosition(self, cameraPos)

    def setTarget(self, cameraPos):
        return _iDynTree.ICamera_setTarget(self, cameraPos)

    def getPosition(self):
        return _iDynTree.ICamera_getPosition(self)

    def getTarget(self):
        return _iDynTree.ICamera_getTarget(self)

    def setUpVector(self, upVector):
        return _iDynTree.ICamera_setUpVector(self, upVector)

    def animator(self):
        return _iDynTree.ICamera_animator(self)

# Register ICamera in _iDynTree:
_iDynTree.ICamera_swigregister(ICamera)

class ColorViz(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_iDynTree.ColorViz_r_get, _iDynTree.ColorViz_r_set)
    g = property(_iDynTree.ColorViz_g_get, _iDynTree.ColorViz_g_set)
    b = property(_iDynTree.ColorViz_b_get, _iDynTree.ColorViz_b_set)
    a = property(_iDynTree.ColorViz_a_get, _iDynTree.ColorViz_a_set)

    def __init__(self, *args):
        _iDynTree.ColorViz_swiginit(self, _iDynTree.new_ColorViz(*args))
    __swig_destroy__ = _iDynTree.delete_ColorViz

# Register ColorViz in _iDynTree:
_iDynTree.ColorViz_swigregister(ColorViz)

class PixelViz(ColorViz):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width = property(_iDynTree.PixelViz_width_get, _iDynTree.PixelViz_width_set)
    height = property(_iDynTree.PixelViz_height_get, _iDynTree.PixelViz_height_set)

    def __init__(self):
        _iDynTree.PixelViz_swiginit(self, _iDynTree.new_PixelViz())
    __swig_destroy__ = _iDynTree.delete_PixelViz

# Register PixelViz in _iDynTree:
_iDynTree.PixelViz_swigregister(PixelViz)

POINT_LIGHT = _iDynTree.POINT_LIGHT
DIRECTIONAL_LIGHT = _iDynTree.DIRECTIONAL_LIGHT
class ILight(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ILight

    def getName(self):
        return _iDynTree.ILight_getName(self)

    def setType(self, type):
        return _iDynTree.ILight_setType(self, type)

    def getType(self):
        return _iDynTree.ILight_getType(self)

    def setPosition(self, cameraPos):
        return _iDynTree.ILight_setPosition(self, cameraPos)

    def getPosition(self):
        return _iDynTree.ILight_getPosition(self)

    def setDirection(self, lightDirection):
        return _iDynTree.ILight_setDirection(self, lightDirection)

    def getDirection(self):
        return _iDynTree.ILight_getDirection(self)

    def setAmbientColor(self, ambientColor):
        return _iDynTree.ILight_setAmbientColor(self, ambientColor)

    def getAmbientColor(self):
        return _iDynTree.ILight_getAmbientColor(self)

    def setSpecularColor(self, ambientColor):
        return _iDynTree.ILight_setSpecularColor(self, ambientColor)

    def getSpecularColor(self):
        return _iDynTree.ILight_getSpecularColor(self)

    def setDiffuseColor(self, ambientColor):
        return _iDynTree.ILight_setDiffuseColor(self, ambientColor)

    def getDiffuseColor(self):
        return _iDynTree.ILight_getDiffuseColor(self)

# Register ILight in _iDynTree:
_iDynTree.ILight_swigregister(ILight)

class IEnvironment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IEnvironment

    def getElements(self):
        return _iDynTree.IEnvironment_getElements(self)

    def setElementVisibility(self, elementKey, isVisible):
        return _iDynTree.IEnvironment_setElementVisibility(self, elementKey, isVisible)

    def setBackgroundColor(self, backgroundColor):
        return _iDynTree.IEnvironment_setBackgroundColor(self, backgroundColor)

    def setFloorGridColor(self, floorGridColor):
        return _iDynTree.IEnvironment_setFloorGridColor(self, floorGridColor)

    def setAmbientLight(self, ambientLight):
        return _iDynTree.IEnvironment_setAmbientLight(self, ambientLight)

    def getLights(self):
        return _iDynTree.IEnvironment_getLights(self)

    def addLight(self, lightName):
        return _iDynTree.IEnvironment_addLight(self, lightName)

    def lightViz(self, lightName):
        return _iDynTree.IEnvironment_lightViz(self, lightName)

    def removeLight(self, lightName):
        return _iDynTree.IEnvironment_removeLight(self, lightName)

# Register IEnvironment in _iDynTree:
_iDynTree.IEnvironment_swigregister(IEnvironment)

class IJetsVisualization(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IJetsVisualization

    def setJetsFrames(self, jetsFrames):
        return _iDynTree.IJetsVisualization_setJetsFrames(self, jetsFrames)

    def getNrOfJets(self):
        return _iDynTree.IJetsVisualization_getNrOfJets(self)

    def getJetDirection(self, jetIndex):
        return _iDynTree.IJetsVisualization_getJetDirection(self, jetIndex)

    def setJetDirection(self, jetIndex, jetDirection):
        return _iDynTree.IJetsVisualization_setJetDirection(self, jetIndex, jetDirection)

    def setJetColor(self, jetIndex, jetColor):
        return _iDynTree.IJetsVisualization_setJetColor(self, jetIndex, jetColor)

    def setJetsDimensions(self, minRadius, maxRadius, maxLenght):
        return _iDynTree.IJetsVisualization_setJetsDimensions(self, minRadius, maxRadius, maxLenght)

    def setJetsIntensity(self, jetsIntensity):
        return _iDynTree.IJetsVisualization_setJetsIntensity(self, jetsIntensity)

# Register IJetsVisualization in _iDynTree:
_iDynTree.IJetsVisualization_swigregister(IJetsVisualization)

class ILabel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ILabel

    def setText(self, text):
        return _iDynTree.ILabel_setText(self, text)

    def getText(self):
        return _iDynTree.ILabel_getText(self)

    def setSize(self, *args):
        return _iDynTree.ILabel_setSize(self, *args)

    def width(self):
        return _iDynTree.ILabel_width(self)

    def height(self):
        return _iDynTree.ILabel_height(self)

    def setPosition(self, position):
        return _iDynTree.ILabel_setPosition(self, position)

    def getPosition(self):
        return _iDynTree.ILabel_getPosition(self)

    def setColor(self, color):
        return _iDynTree.ILabel_setColor(self, color)

    def setVisible(self, visible=True):
        return _iDynTree.ILabel_setVisible(self, visible)

# Register ILabel in _iDynTree:
_iDynTree.ILabel_swigregister(ILabel)

class IVectorsVisualization(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IVectorsVisualization

    def addVector(self, *args):
        return _iDynTree.IVectorsVisualization_addVector(self, *args)

    def getNrOfVectors(self):
        return _iDynTree.IVectorsVisualization_getNrOfVectors(self)

    def getVector(self, *args):
        return _iDynTree.IVectorsVisualization_getVector(self, *args)

    def updateVector(self, *args):
        return _iDynTree.IVectorsVisualization_updateVector(self, *args)

    def setVectorColor(self, vectorIndex, vectorColor):
        return _iDynTree.IVectorsVisualization_setVectorColor(self, vectorIndex, vectorColor)

    def setVectorsDefaultColor(self, vectorColor):
        return _iDynTree.IVectorsVisualization_setVectorsDefaultColor(self, vectorColor)

    def setVectorsColor(self, vectorColor):
        return _iDynTree.IVectorsVisualization_setVectorsColor(self, vectorColor)

    def setVectorsAspect(self, zeroModulusRadius, modulusMultiplier, heightScale):
        return _iDynTree.IVectorsVisualization_setVectorsAspect(self, zeroModulusRadius, modulusMultiplier, heightScale)

    def setVisible(self, vectorIndex, visible=True):
        return _iDynTree.IVectorsVisualization_setVisible(self, vectorIndex, visible)

    def getVectorLabel(self, vectorIndex):
        return _iDynTree.IVectorsVisualization_getVectorLabel(self, vectorIndex)

# Register IVectorsVisualization in _iDynTree:
_iDynTree.IVectorsVisualization_swigregister(IVectorsVisualization)

class IFrameVisualization(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IFrameVisualization

    def addFrame(self, transformation, arrowLength=1.0):
        return _iDynTree.IFrameVisualization_addFrame(self, transformation, arrowLength)

    def setVisible(self, frameIndex, isVisible):
        return _iDynTree.IFrameVisualization_setVisible(self, frameIndex, isVisible)

    def getNrOfFrames(self):
        return _iDynTree.IFrameVisualization_getNrOfFrames(self)

    def getFrameTransform(self, frameIndex, currentTransform):
        return _iDynTree.IFrameVisualization_getFrameTransform(self, frameIndex, currentTransform)

    def updateFrame(self, frameIndex, transformation):
        return _iDynTree.IFrameVisualization_updateFrame(self, frameIndex, transformation)

    def getFrameLabel(self, frameIndex):
        return _iDynTree.IFrameVisualization_getFrameLabel(self, frameIndex)

# Register IFrameVisualization in _iDynTree:
_iDynTree.IFrameVisualization_swigregister(IFrameVisualization)

class IModelVisualization(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_IModelVisualization

    def setPositions(self, world_H_base, jointPos):
        return _iDynTree.IModelVisualization_setPositions(self, world_H_base, jointPos)

    def setLinkPositions(self, linkPos):
        return _iDynTree.IModelVisualization_setLinkPositions(self, linkPos)

    def model(self):
        return _iDynTree.IModelVisualization_model(self)

    def getInstanceName(self):
        return _iDynTree.IModelVisualization_getInstanceName(self)

    def setModelVisibility(self, isVisible):
        return _iDynTree.IModelVisualization_setModelVisibility(self, isVisible)

    def setModelColor(self, modelColor):
        return _iDynTree.IModelVisualization_setModelColor(self, modelColor)

    def resetModelColor(self):
        return _iDynTree.IModelVisualization_resetModelColor(self)

    def setLinkColor(self, linkIndex, linkColor):
        return _iDynTree.IModelVisualization_setLinkColor(self, linkIndex, linkColor)

    def resetLinkColor(self, linkIndex):
        return _iDynTree.IModelVisualization_resetLinkColor(self, linkIndex)

    def getLinkNames(self):
        return _iDynTree.IModelVisualization_getLinkNames(self)

    def setLinkVisibility(self, linkName, isVisible):
        return _iDynTree.IModelVisualization_setLinkVisibility(self, linkName, isVisible)

    def getFeatures(self):
        return _iDynTree.IModelVisualization_getFeatures(self)

    def setFeatureVisibility(self, elementKey, isVisible):
        return _iDynTree.IModelVisualization_setFeatureVisibility(self, elementKey, isVisible)

    def jets(self):
        return _iDynTree.IModelVisualization_jets(self)

    def getWorldLinkTransform(self, *args):
        return _iDynTree.IModelVisualization_getWorldLinkTransform(self, *args)

    def getWorldFrameTransform(self, *args):
        return _iDynTree.IModelVisualization_getWorldFrameTransform(self, *args)

    def label(self):
        return _iDynTree.IModelVisualization_label(self)

# Register IModelVisualization in _iDynTree:
_iDynTree.IModelVisualization_swigregister(IModelVisualization)

class ITexture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ITexture

    def environment(self):
        return _iDynTree.ITexture_environment(self)

    def getPixelColor(self, width, height):
        return _iDynTree.ITexture_getPixelColor(self, width, height)

    def getPixels(self, pixels):
        return _iDynTree.ITexture_getPixels(self, pixels)

    def drawToFile(self, *args):
        return _iDynTree.ITexture_drawToFile(self, *args)

    def enableDraw(self, enabled=True):
        return _iDynTree.ITexture_enableDraw(self, enabled)

    def width(self):
        return _iDynTree.ITexture_width(self)

    def height(self):
        return _iDynTree.ITexture_height(self)

    def setSubDrawArea(self, xOffsetFromTopLeft, yOffsetFromTopLeft, subImageWidth, subImageHeight):
        return _iDynTree.ITexture_setSubDrawArea(self, xOffsetFromTopLeft, yOffsetFromTopLeft, subImageWidth, subImageHeight)

# Register ITexture in _iDynTree:
_iDynTree.ITexture_swigregister(ITexture)

class VisualizerOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    verbose = property(_iDynTree.VisualizerOptions_verbose_get, _iDynTree.VisualizerOptions_verbose_set)
    winWidth = property(_iDynTree.VisualizerOptions_winWidth_get, _iDynTree.VisualizerOptions_winWidth_set)
    winHeight = property(_iDynTree.VisualizerOptions_winHeight_get, _iDynTree.VisualizerOptions_winHeight_set)
    rootFrameArrowsDimension = property(_iDynTree.VisualizerOptions_rootFrameArrowsDimension_get, _iDynTree.VisualizerOptions_rootFrameArrowsDimension_set)

    def __init__(self):
        _iDynTree.VisualizerOptions_swiginit(self, _iDynTree.new_VisualizerOptions())
    __swig_destroy__ = _iDynTree.delete_VisualizerOptions

# Register VisualizerOptions in _iDynTree:
_iDynTree.VisualizerOptions_swigregister(VisualizerOptions)

class ITexturesHandler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _iDynTree.delete_ITexturesHandler

    def add(self, *args):
        return _iDynTree.ITexturesHandler_add(self, *args)

    def get(self, name):
        return _iDynTree.ITexturesHandler_get(self, name)

# Register ITexturesHandler in _iDynTree:
_iDynTree.ITexturesHandler_swigregister(ITexturesHandler)

class Visualizer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.Visualizer_swiginit(self, _iDynTree.new_Visualizer())
    __swig_destroy__ = _iDynTree.delete_Visualizer

    def init(self, *args):
        return _iDynTree.Visualizer_init(self, *args)

    def getNrOfVisualizedModels(self):
        return _iDynTree.Visualizer_getNrOfVisualizedModels(self)

    def getModelInstanceName(self, modelInstanceIndex):
        return _iDynTree.Visualizer_getModelInstanceName(self, modelInstanceIndex)

    def getModelInstanceIndex(self, instanceName):
        return _iDynTree.Visualizer_getModelInstanceIndex(self, instanceName)

    def addModel(self, model, instanceName):
        return _iDynTree.Visualizer_addModel(self, model, instanceName)

    def modelViz(self, *args):
        return _iDynTree.Visualizer_modelViz(self, *args)

    def camera(self):
        return _iDynTree.Visualizer_camera(self)

    def enviroment(self):
        return _iDynTree.Visualizer_enviroment(self)

    def environment(self):
        return _iDynTree.Visualizer_environment(self)

    def vectors(self):
        return _iDynTree.Visualizer_vectors(self)

    def frames(self):
        return _iDynTree.Visualizer_frames(self)

    def textures(self):
        return _iDynTree.Visualizer_textures(self)

    def getLabel(self, labelName):
        return _iDynTree.Visualizer_getLabel(self, labelName)

    def width(self):
        return _iDynTree.Visualizer_width(self)

    def height(self):
        return _iDynTree.Visualizer_height(self)

    def run(self):
        return _iDynTree.Visualizer_run(self)

    def draw(self):
        return _iDynTree.Visualizer_draw(self)

    def subDraw(self, xOffsetFromTopLeft, yOffsetFromTopLeft, subImageWidth, subImageHeight):
        return _iDynTree.Visualizer_subDraw(self, xOffsetFromTopLeft, yOffsetFromTopLeft, subImageWidth, subImageHeight)

    def drawToFile(self, *args):
        return _iDynTree.Visualizer_drawToFile(self, *args)

    def close(self):
        return _iDynTree.Visualizer_close(self)

    def isWindowActive(self):
        return _iDynTree.Visualizer_isWindowActive(self)

    def setColorPalette(self, name):
        return _iDynTree.Visualizer_setColorPalette(self, name)

# Register Visualizer in _iDynTree:
_iDynTree.Visualizer_swigregister(Visualizer)

class Polygon(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_vertices = property(_iDynTree.Polygon_m_vertices_get, _iDynTree.Polygon_m_vertices_set)

    def __init__(self):
        _iDynTree.Polygon_swiginit(self, _iDynTree.new_Polygon())

    def setNrOfVertices(self, size):
        return _iDynTree.Polygon_setNrOfVertices(self, size)

    def getNrOfVertices(self):
        return _iDynTree.Polygon_getNrOfVertices(self)

    def isValid(self):
        return _iDynTree.Polygon_isValid(self)

    def applyTransform(self, newFrame_X_oldFrame):
        return _iDynTree.Polygon_applyTransform(self, newFrame_X_oldFrame)

    def __call__(self, *args):
        return _iDynTree.Polygon___call__(self, *args)

    @staticmethod
    def XYRectangleFromOffsets(front, back, left, right):
        return _iDynTree.Polygon_XYRectangleFromOffsets(front, back, left, right)
    __swig_destroy__ = _iDynTree.delete_Polygon

# Register Polygon in _iDynTree:
_iDynTree.Polygon_swigregister(Polygon)

def Polygon_XYRectangleFromOffsets(front, back, left, right):
    return _iDynTree.Polygon_XYRectangleFromOffsets(front, back, left, right)

class Polygon2D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_vertices = property(_iDynTree.Polygon2D_m_vertices_get, _iDynTree.Polygon2D_m_vertices_set)

    def __init__(self):
        _iDynTree.Polygon2D_swiginit(self, _iDynTree.new_Polygon2D())

    def setNrOfVertices(self, size):
        return _iDynTree.Polygon2D_setNrOfVertices(self, size)

    def getNrOfVertices(self):
        return _iDynTree.Polygon2D_getNrOfVertices(self)

    def isValid(self):
        return _iDynTree.Polygon2D_isValid(self)

    def __call__(self, *args):
        return _iDynTree.Polygon2D___call__(self, *args)
    __swig_destroy__ = _iDynTree.delete_Polygon2D

# Register Polygon2D in _iDynTree:
_iDynTree.Polygon2D_swigregister(Polygon2D)

class ConvexHullProjectionConstraint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def setActive(self, isActive):
        return _iDynTree.ConvexHullProjectionConstraint_setActive(self, isActive)

    def isActive(self):
        return _iDynTree.ConvexHullProjectionConstraint_isActive(self)

    def getNrOfConstraints(self):
        return _iDynTree.ConvexHullProjectionConstraint_getNrOfConstraints(self)
    projectedConvexHull = property(_iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_get, _iDynTree.ConvexHullProjectionConstraint_projectedConvexHull_set)
    A = property(_iDynTree.ConvexHullProjectionConstraint_A_get, _iDynTree.ConvexHullProjectionConstraint_A_set)
    b = property(_iDynTree.ConvexHullProjectionConstraint_b_get, _iDynTree.ConvexHullProjectionConstraint_b_set)
    P = property(_iDynTree.ConvexHullProjectionConstraint_P_get, _iDynTree.ConvexHullProjectionConstraint_P_set)
    Pdirection = property(_iDynTree.ConvexHullProjectionConstraint_Pdirection_get, _iDynTree.ConvexHullProjectionConstraint_Pdirection_set)
    AtimesP = property(_iDynTree.ConvexHullProjectionConstraint_AtimesP_get, _iDynTree.ConvexHullProjectionConstraint_AtimesP_set)
    o = property(_iDynTree.ConvexHullProjectionConstraint_o_get, _iDynTree.ConvexHullProjectionConstraint_o_set)

    def buildConvexHull(self, xAxisOfPlaneInWorld, yAxisOfPlaneInWorld, originOfPlaneInWorld, supportPolygonsExpressedInSupportFrame, absoluteFrame_X_supportFrame):
        return _iDynTree.ConvexHullProjectionConstraint_buildConvexHull(self, xAxisOfPlaneInWorld, yAxisOfPlaneInWorld, originOfPlaneInWorld, supportPolygonsExpressedInSupportFrame, absoluteFrame_X_supportFrame)
    supportFrameIndices = property(_iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_get, _iDynTree.ConvexHullProjectionConstraint_supportFrameIndices_set)
    absoluteFrame_X_supportFrame = property(_iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get, _iDynTree.ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set)

    def project(self, posIn3dInAbsoluteFrame):
        return _iDynTree.ConvexHullProjectionConstraint_project(self, posIn3dInAbsoluteFrame)

    def computeMargin(self, posIn2D):
        return _iDynTree.ConvexHullProjectionConstraint_computeMargin(self, posIn2D)

    def setProjectionAlongDirection(self, direction):
        return _iDynTree.ConvexHullProjectionConstraint_setProjectionAlongDirection(self, direction)

    def projectAlongDirection(self, posIn3dInAbsoluteFrame):
        return _iDynTree.ConvexHullProjectionConstraint_projectAlongDirection(self, posIn3dInAbsoluteFrame)

    def __init__(self):
        _iDynTree.ConvexHullProjectionConstraint_swiginit(self, _iDynTree.new_ConvexHullProjectionConstraint())
    __swig_destroy__ = _iDynTree.delete_ConvexHullProjectionConstraint

# Register ConvexHullProjectionConstraint in _iDynTree:
_iDynTree.ConvexHullProjectionConstraint_swigregister(ConvexHullProjectionConstraint)

InverseKinematicsRotationParametrizationQuaternion = _iDynTree.InverseKinematicsRotationParametrizationQuaternion
InverseKinematicsRotationParametrizationRollPitchYaw = _iDynTree.InverseKinematicsRotationParametrizationRollPitchYaw

def sizeOfRotationParametrization(rotationParametrization):
    return _iDynTree.sizeOfRotationParametrization(rotationParametrization)
InverseKinematicsTreatTargetAsConstraintNone = _iDynTree.InverseKinematicsTreatTargetAsConstraintNone
InverseKinematicsTreatTargetAsConstraintPositionOnly = _iDynTree.InverseKinematicsTreatTargetAsConstraintPositionOnly
InverseKinematicsTreatTargetAsConstraintRotationOnly = _iDynTree.InverseKinematicsTreatTargetAsConstraintRotationOnly
InverseKinematicsTreatTargetAsConstraintFull = _iDynTree.InverseKinematicsTreatTargetAsConstraintFull
class InverseKinematics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _iDynTree.InverseKinematics_swiginit(self, _iDynTree.new_InverseKinematics())
    __swig_destroy__ = _iDynTree.delete_InverseKinematics

    def loadModelFromFile(self, *args):
        return _iDynTree.InverseKinematics_loadModelFromFile(self, *args)

    def setModel(self, *args):
        return _iDynTree.InverseKinematics_setModel(self, *args)

    def setJointLimits(self, jointLimits):
        return _iDynTree.InverseKinematics_setJointLimits(self, jointLimits)

    def getJointLimits(self, jointLimits):
        return _iDynTree.InverseKinematics_getJointLimits(self, jointLimits)

    def clearProblem(self):
        return _iDynTree.InverseKinematics_clearProblem(self)

    def setFloatingBaseOnFrameNamed(self, floatingBaseFrameName):
        return _iDynTree.InverseKinematics_setFloatingBaseOnFrameNamed(self, floatingBaseFrameName)

    def setCurrentRobotConfiguration(self, *args):
        return _iDynTree.InverseKinematics_setCurrentRobotConfiguration(self, *args)

    def setJointConfiguration(self, jointName, jointConfiguration):
        return _iDynTree.InverseKinematics_setJointConfiguration(self, jointName, jointConfiguration)

    def setRotationParametrization(self, parametrization):
        return _iDynTree.InverseKinematics_setRotationParametrization(self, parametrization)

    def rotationParametrization(self):
        return _iDynTree.InverseKinematics_rotationParametrization(self)

    def setMaxIterations(self, max_iter):
        return _iDynTree.InverseKinematics_setMaxIterations(self, max_iter)

    def maxIterations(self):
        return _iDynTree.InverseKinematics_maxIterations(self)

    def setMaxCPUTime(self, max_cpu_time):
        return _iDynTree.InverseKinematics_setMaxCPUTime(self, max_cpu_time)

    def maxCPUTime(self):
        return _iDynTree.InverseKinematics_maxCPUTime(self)

    def setCostTolerance(self, tol):
        return _iDynTree.InverseKinematics_setCostTolerance(self, tol)

    def costTolerance(self):
        return _iDynTree.InverseKinematics_costTolerance(self)

    def setConstraintsTolerance(self, constr_tol):
        return _iDynTree.InverseKinematics_setConstraintsTolerance(self, constr_tol)

    def constraintsTolerance(self):
        return _iDynTree.InverseKinematics_constraintsTolerance(self)

    def setVerbosity(self, verbose):
        return _iDynTree.InverseKinematics_setVerbosity(self, verbose)

    def linearSolverName(self):
        return _iDynTree.InverseKinematics_linearSolverName(self)

    def setLinearSolverName(self, solverName):
        return _iDynTree.InverseKinematics_setLinearSolverName(self, solverName)

    def addFrameConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFrameConstraint(self, *args)

    def addFramePositionConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFramePositionConstraint(self, *args)

    def addFrameRotationConstraint(self, *args):
        return _iDynTree.InverseKinematics_addFrameRotationConstraint(self, *args)

    def activateFrameConstraint(self, *args):
        return _iDynTree.InverseKinematics_activateFrameConstraint(self, *args)

    def deactivateFrameConstraint(self, frameName):
        return _iDynTree.InverseKinematics_deactivateFrameConstraint(self, frameName)

    def isFrameConstraintActive(self, frameName):
        return _iDynTree.InverseKinematics_isFrameConstraintActive(self, frameName)

    def addCenterOfMassProjectionConstraint(self, *args):
        return _iDynTree.InverseKinematics_addCenterOfMassProjectionConstraint(self, *args)

    def getCenterOfMassProjectionMargin(self):
        return _iDynTree.InverseKinematics_getCenterOfMassProjectionMargin(self)

    def getCenterOfMassProjectConstraintConvexHull(self, convexHull):
        return _iDynTree.InverseKinematics_getCenterOfMassProjectConstraintConvexHull(self, convexHull)

    def addTarget(self, *args):
        return _iDynTree.InverseKinematics_addTarget(self, *args)

    def addPositionTarget(self, *args):
        return _iDynTree.InverseKinematics_addPositionTarget(self, *args)

    def addRotationTarget(self, *args):
        return _iDynTree.InverseKinematics_addRotationTarget(self, *args)

    def updateTarget(self, *args):
        return _iDynTree.InverseKinematics_updateTarget(self, *args)

    def updatePositionTarget(self, *args):
        return _iDynTree.InverseKinematics_updatePositionTarget(self, *args)

    def updateRotationTarget(self, *args):
        return _iDynTree.InverseKinematics_updateRotationTarget(self, *args)

    def setDefaultTargetResolutionMode(self, mode):
        return _iDynTree.InverseKinematics_setDefaultTargetResolutionMode(self, mode)

    def defaultTargetResolutionMode(self):
        return _iDynTree.InverseKinematics_defaultTargetResolutionMode(self)

    def setTargetResolutionMode(self, targetName, mode):
        return _iDynTree.InverseKinematics_setTargetResolutionMode(self, targetName, mode)

    def targetResolutionMode(self, frameName):
        return _iDynTree.InverseKinematics_targetResolutionMode(self, frameName)

    def setDesiredFullJointsConfiguration(self, *args):
        return _iDynTree.InverseKinematics_setDesiredFullJointsConfiguration(self, *args)

    def setDesiredReducedJointConfiguration(self, *args):
        return _iDynTree.InverseKinematics_setDesiredReducedJointConfiguration(self, *args)

    def setFullJointsInitialCondition(self, baseTransform, initialCondition):
        return _iDynTree.InverseKinematics_setFullJointsInitialCondition(self, baseTransform, initialCondition)

    def setReducedInitialCondition(self, baseTransform, initialCondition):
        return _iDynTree.InverseKinematics_setReducedInitialCondition(self, baseTransform, initialCondition)

    def solve(self):
        return _iDynTree.InverseKinematics_solve(self)

    def getFullJointsSolution(self, *args):
        return _iDynTree.InverseKinematics_getFullJointsSolution(self, *args)

    def getReducedSolution(self, *args):
        return _iDynTree.InverseKinematics_getReducedSolution(self, *args)

    def getPoseForFrame(self, *args):
        return _iDynTree.InverseKinematics_getPoseForFrame(self, *args)

    def fullModel(self):
        return _iDynTree.InverseKinematics_fullModel(self)

    def reducedModel(self):
        return _iDynTree.InverseKinematics_reducedModel(self)

    def setCOMTarget(self, *args):
        return _iDynTree.InverseKinematics_setCOMTarget(self, *args)

    def setCOMAsConstraint(self, asConstraint=True):
        return _iDynTree.InverseKinematics_setCOMAsConstraint(self, asConstraint)

    def setCOMAsConstraintTolerance(self, tolerance=1e-8):
        return _iDynTree.InverseKinematics_setCOMAsConstraintTolerance(self, tolerance)

    def isCOMAConstraint(self):
        return _iDynTree.InverseKinematics_isCOMAConstraint(self)

    def isCOMTargetActive(self):
        return _iDynTree.InverseKinematics_isCOMTargetActive(self)

    def deactivateCOMTarget(self):
        return _iDynTree.InverseKinematics_deactivateCOMTarget(self)

    def setCOMConstraintProjectionDirection(self, *args):
        return _iDynTree.InverseKinematics_setCOMConstraintProjectionDirection(self, *args)

# Register InverseKinematics in _iDynTree:
_iDynTree.InverseKinematics_swigregister(InverseKinematics)



